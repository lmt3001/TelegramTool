import {
  boolean,
  define,
  literal,
  nullable,
  number,
  object,
  record,
  string,
  union
} from "superstruct";
import { fromB58, splitGenericParameters } from "@mysten/bcs";
const TransactionDigest = string();
const TransactionEffectsDigest = string();
const TransactionEventDigest = string();
const ObjectId = string();
const SuiAddress = string();
const SequenceNumber = string();
const ObjectOwner = union([
  object({
    AddressOwner: SuiAddress
  }),
  object({
    ObjectOwner: SuiAddress
  }),
  object({
    Shared: object({
      initial_shared_version: number()
    })
  }),
  literal("Immutable")
]);
const SuiJsonValue = define("SuiJsonValue", () => true);
const ProtocolConfigValue = union([
  object({ u32: string() }),
  object({ u64: string() }),
  object({ f64: string() })
]);
const ProtocolConfig = object({
  attributes: record(string(), nullable(ProtocolConfigValue)),
  featureFlags: record(string(), boolean()),
  maxSupportedProtocolVersion: string(),
  minSupportedProtocolVersion: string(),
  protocolVersion: string()
});
const TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = fromB58(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e) {
    return false;
  }
}
const SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function parseTypeTag(type) {
  if (!type.includes("::"))
    return type;
  return parseStructTag(type);
}
function parseStructTag(type) {
  const [address, module] = type.split("::");
  const rest = type.slice(address.length + module.length + 4);
  const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: normalizeSuiAddress(address),
    module,
    name,
    typeParams
  };
}
function normalizeStructTag(type) {
  const { address, module, name, typeParams } = typeof type === "string" ? parseStructTag(type) : type;
  const formattedTypeParams = typeParams.length > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module}::${name}${formattedTypeParams}`;
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}
export {
  ObjectId,
  ObjectOwner,
  ProtocolConfig,
  SUI_ADDRESS_LENGTH,
  SequenceNumber,
  SuiAddress,
  SuiJsonValue,
  TransactionDigest,
  TransactionEffectsDigest,
  TransactionEventDigest,
  isValidSuiAddress,
  isValidSuiObjectId,
  isValidTransactionDigest,
  normalizeStructTag,
  normalizeSuiAddress,
  normalizeSuiObjectId,
  parseStructTag
};
//# sourceMappingURL=common.js.map
