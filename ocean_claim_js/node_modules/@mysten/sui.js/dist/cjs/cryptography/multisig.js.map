{
  "version": 3,
  "sources": ["../../../src/cryptography/multisig.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport type { SerializedSignature, SignaturePubkeyPair, SignatureScheme } from './signature.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature.js';\n// eslint-disable-next-line import/no-cycle\nimport { toSingleSignaturePubkeyPair } from './utils.js';\nimport type { PublicKey } from './publickey.js';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { normalizeSuiAddress } from '../types/index.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\nimport { builder } from '../builder/bcs.js';\n\nexport type PubkeyWeightPair = {\n\tpubKey: PublicKey;\n\tweight: number;\n};\n\nexport type CompressedSignature =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] };\n\nexport type PublicKeyEnum =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] };\n\nexport type PubkeyEnumWeightPair = {\n\tpubKey: PublicKeyEnum;\n\tweight: number;\n};\n\nexport type MultiSigPublicKey = {\n\tpk_map: PubkeyEnumWeightPair[];\n\tthreshold: number;\n};\n\nexport type MultiSig = {\n\tsigs: CompressedSignature[];\n\tbitmap: number;\n\tmultisig_pk: MultiSigPublicKey;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\n\n/// Derives a multisig address from a list of pk and weights and threshold.\n// It is the 32-byte Blake2b hash of the serializd bytes of `flag_MultiSig || threshold || flag_1 || pk_1 || weight_1\n/// || ... || flag_n || pk_n || weight_n`\nexport function toMultiSigAddress(pks: PubkeyWeightPair[], threshold: number): string {\n\tif (pks.length > MAX_SIGNER_IN_MULTISIG) {\n\t\tthrow new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t}\n\t// max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n\tlet maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n\tlet tmp = new Uint8Array(maxLength);\n\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n\tlet arr = to_uint8array(threshold);\n\ttmp.set(arr, 1);\n\tlet i = 3;\n\tfor (const pk of pks) {\n\t\ttmp.set([pk.pubKey.flag()], i);\n\t\ttmp.set(pk.pubKey.toBytes(), i + 1);\n\t\ttmp.set([pk.weight], i + 1 + pk.pubKey.toBytes().length);\n\t\ti += pk.pubKey.toBytes().length + 2;\n\t}\n\treturn normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));\n}\n\n/// Combine a list of serialized sigs, a list of pk weight pairs\n/// and threshold into a single multisig. `sigs` are required to\n/// be in the same order as `pks`. e.g. for [pk1, pk2, pk3, pk4, pk5],\n/// [sig1, sig2, sig5] is valid, but [sig2, sig1, sig5] is invalid.\nexport function combinePartialSigs(\n\tsigs: SerializedSignature[],\n\tpks: PubkeyWeightPair[],\n\tthreshold: number,\n): SerializedSignature {\n\tlet multisig_pk: MultiSigPublicKey = {\n\t\tpk_map: pks.map((x) => toPkWeightPair(x)),\n\t\tthreshold: threshold,\n\t};\n\n\tlet bitmap = 0;\n\tlet compressed_sigs: CompressedSignature[] = new Array(sigs.length);\n\tfor (let i = 0; i < sigs.length; i++) {\n\t\tlet parsed = toSingleSignaturePubkeyPair(sigs[i]);\n\t\tlet bytes = Array.from(parsed.signature.map((x) => Number(x)));\n\t\tif (parsed.signatureScheme === 'ED25519') {\n\t\t\tcompressed_sigs[i] = { ED25519: bytes };\n\t\t} else if (parsed.signatureScheme === 'Secp256k1') {\n\t\t\tcompressed_sigs[i] = { Secp256k1: bytes };\n\t\t} else if (parsed.signatureScheme === 'Secp256r1') {\n\t\t\tcompressed_sigs[i] = { Secp256r1: bytes };\n\t\t}\n\t\tfor (let j = 0; j < pks.length; j++) {\n\t\t\tif (parsed.pubKey.equals(pks[j].pubKey)) {\n\t\t\t\tbitmap |= 1 << j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlet multisig: MultiSig = {\n\t\tsigs: compressed_sigs,\n\t\tbitmap,\n\t\tmultisig_pk,\n\t};\n\n\tconst bytes = builder.ser('MultiSig', multisig).toBytes();\n\tlet tmp = new Uint8Array(bytes.length + 1);\n\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\ttmp.set(bytes, 1);\n\treturn toB64(tmp);\n}\n\n/// Decode a multisig signature into a list of signatures, public keys and flags.\nexport function decodeMultiSig(signature: string): SignaturePubkeyPair[] {\n\tconst parsed = fromB64(signature);\n\tif (parsed.length < 1 || parsed[0] !== SIGNATURE_SCHEME_TO_FLAG['MultiSig']) {\n\t\tthrow new Error('Invalid MultiSig flag');\n\t}\n\tconst multisig: MultiSig = builder.de('MultiSig', parsed.slice(1));\n\tlet res: SignaturePubkeyPair[] = new Array(multisig.sigs.length);\n\tfor (let i = 0; i < multisig.sigs.length; i++) {\n\t\tlet s: CompressedSignature = multisig.sigs[i];\n\t\tlet pk_index = as_indices(multisig.bitmap).at(i);\n\t\tlet pk_bytes = Object.values(multisig.multisig_pk.pk_map[pk_index as number].pubKey)[0];\n\t\tconst scheme = Object.keys(s)[0] as SignatureScheme;\n\n\t\tif (scheme === 'MultiSig') {\n\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t}\n\n\t\tconst SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n\t\t\tED25519: Ed25519PublicKey,\n\t\t\tSecp256k1: Secp256k1PublicKey,\n\t\t\tSecp256r1: Secp256r1PublicKey,\n\t\t};\n\n\t\tconst PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[scheme];\n\n\t\tres[i] = {\n\t\t\tsignatureScheme: scheme,\n\t\t\tsignature: Uint8Array.from(Object.values(s)[0]),\n\t\t\tpubKey: new PublicKey(pk_bytes),\n\t\t};\n\t}\n\treturn res;\n}\n\nfunction toPkWeightPair(pair: PubkeyWeightPair): PubkeyEnumWeightPair {\n\tlet pk_bytes = Array.from(pair.pubKey.toBytes().map((x) => Number(x)));\n\tswitch (pair.pubKey.flag()) {\n\t\tcase SIGNATURE_SCHEME_TO_FLAG['Secp256k1']:\n\t\t\treturn {\n\t\t\t\tpubKey: {\n\t\t\t\t\tSecp256k1: pk_bytes,\n\t\t\t\t},\n\t\t\t\tweight: pair.weight,\n\t\t\t};\n\t\tcase SIGNATURE_SCHEME_TO_FLAG['Secp256r1']:\n\t\t\treturn {\n\t\t\t\tpubKey: {\n\t\t\t\t\tSecp256r1: pk_bytes,\n\t\t\t\t},\n\t\t\t\tweight: pair.weight,\n\t\t\t};\n\t\tcase SIGNATURE_SCHEME_TO_FLAG['ED25519']:\n\t\t\treturn {\n\t\t\t\tpubKey: {\n\t\t\t\t\tED25519: pk_bytes,\n\t\t\t\t},\n\t\t\t\tweight: pair.weight,\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported signature scheme');\n\t}\n}\n\n/// Convert u16 to Uint8Array of length 2 in little endian.\nfunction to_uint8array(threshold: number): Uint8Array {\n\tif (threshold < 0 || threshold > 65535) {\n\t\tthrow new Error('Invalid threshold');\n\t}\n\tlet arr = new Uint8Array(2);\n\tarr[0] = threshold & 0xff;\n\tarr[1] = threshold >> 8;\n\treturn arr;\n}\n\nfunction as_indices(bitmap: number): Uint8Array {\n\tif (bitmap < 0 || bitmap > 1024) {\n\t\tthrow new Error('Invalid bitmap');\n\t}\n\tlet res: number[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tif ((bitmap & (1 << i)) !== 0) {\n\t\t\tres.push(i);\n\t\t}\n\t}\n\treturn Uint8Array.from(res);\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "import_publickey", "import_bcs", "bytes"]
}
