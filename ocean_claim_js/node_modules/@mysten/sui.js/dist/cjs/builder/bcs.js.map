{
  "version": 3,
  "sources": ["../../../src/builder/bcs.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { TypeName } from '@mysten/bcs';\nimport { BCS } from '@mysten/bcs';\nimport { bcs } from '../types/sui-bcs.js';\nimport type { TypeTag } from '../types/index.js';\nimport { normalizeSuiAddress } from '../types/index.js';\nimport { TypeTagSerializer } from '../signers/txn-data-serializers/type-tag-serializer.js';\nimport type { TransactionArgument, MoveCallTransaction } from './Transactions.js';\n\nexport const ARGUMENT_INNER = 'Argument';\nexport const VECTOR = 'vector';\nexport const OPTION = 'Option';\nexport const CALL_ARG = 'CallArg';\nexport const TYPE_TAG = 'TypeTag';\nexport const OBJECT_ARG = 'ObjectArg';\nexport const PROGRAMMABLE_TX_BLOCK = 'ProgrammableTransaction';\nexport const PROGRAMMABLE_CALL_INNER = 'ProgrammableMoveCall';\nexport const TRANSACTION_INNER = 'Transaction';\nexport const COMPRESSED_SIGNATURE = 'CompressedSignature';\nexport const PUBLIC_KEY = 'PublicKey';\nexport const MULTISIG_PUBLIC_KEY = 'MultiSigPublicKey';\nexport const MULTISIG_PK_MAP = 'MultiSigPkMap';\nexport const MULTISIG = 'MultiSig';\n\nexport const ENUM_KIND = 'EnumKind';\n\n/** Wrapper around transaction Enum to support `kind` matching in TS */\nexport const TRANSACTION: TypeName = [ENUM_KIND, TRANSACTION_INNER];\n/** Wrapper around Argument Enum to support `kind` matching in TS */\nexport const ARGUMENT: TypeName = [ENUM_KIND, ARGUMENT_INNER];\n\n/** Custom serializer for decoding package, module, function easier */\nexport const PROGRAMMABLE_CALL = 'SimpleProgrammableMoveCall';\n\n/** Transaction types */\n\nexport type Option<T> = { some: T } | { none: true };\n\nexport const builder = new BCS(bcs);\nregisterFixedArray(builder, 'FixedArray[64]', 64);\nregisterFixedArray(builder, 'FixedArray[33]', 33);\nregisterFixedArray(builder, 'FixedArray[32]', 32);\n\nbuilder\n\t.registerStructType(PROGRAMMABLE_TX_BLOCK, {\n\t\tinputs: [VECTOR, CALL_ARG],\n\t\ttransactions: [VECTOR, TRANSACTION],\n\t})\n\t.registerEnumType(ARGUMENT_INNER, {\n\t\tGasCoin: null,\n\t\tInput: { index: BCS.U16 },\n\t\tResult: { index: BCS.U16 },\n\t\tNestedResult: { index: BCS.U16, resultIndex: BCS.U16 },\n\t})\n\t.registerStructType(PROGRAMMABLE_CALL_INNER, {\n\t\tpackage: BCS.ADDRESS,\n\t\tmodule: BCS.STRING,\n\t\tfunction: BCS.STRING,\n\t\ttype_arguments: [VECTOR, TYPE_TAG],\n\t\targuments: [VECTOR, ARGUMENT],\n\t})\n\t// Keep this in sync with crates/sui-types/src/messages.rs\n\t.registerEnumType(TRANSACTION_INNER, {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: PROGRAMMABLE_CALL,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: {\n\t\t\tobjects: [VECTOR, ARGUMENT],\n\t\t\taddress: ARGUMENT,\n\t\t},\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: { coin: ARGUMENT, amounts: [VECTOR, ARGUMENT] },\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: { destination: ARGUMENT, sources: [VECTOR, ARGUMENT] },\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: {\n\t\t\tmodules: [VECTOR, [VECTOR, BCS.U8]],\n\t\t\tdependencies: [VECTOR, BCS.ADDRESS],\n\t\t},\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: {\n\t\t\ttype: [OPTION, TYPE_TAG],\n\t\t\tobjects: [VECTOR, ARGUMENT],\n\t\t},\n\t\t/**  */\n\t\tUpgrade: {\n\t\t\tmodules: [VECTOR, [VECTOR, BCS.U8]],\n\t\t\tdependencies: [VECTOR, BCS.ADDRESS],\n\t\t\tpackageId: BCS.ADDRESS,\n\t\t\tticket: ARGUMENT,\n\t\t},\n\t})\n\t.registerEnumType(COMPRESSED_SIGNATURE, {\n\t\tED25519: ['FixedArray[64]', 'u8'],\n\t\tSecp256k1: ['FixedArray[64]', 'u8'],\n\t\tSecp256r1: ['FixedArray[64]', 'u8'],\n\t})\n\t.registerEnumType(PUBLIC_KEY, {\n\t\tED25519: ['FixedArray[32]', 'u8'],\n\t\tSecp256k1: ['FixedArray[33]', 'u8'],\n\t\tSecp256r1: ['FixedArray[33]', 'u8'],\n\t})\n\t.registerStructType(MULTISIG_PK_MAP, {\n\t\tpubKey: PUBLIC_KEY,\n\t\tweight: BCS.U8,\n\t})\n\t.registerStructType(MULTISIG_PUBLIC_KEY, {\n\t\tpk_map: [VECTOR, MULTISIG_PK_MAP],\n\t\tthreshold: BCS.U16,\n\t})\n\t.registerStructType(MULTISIG, {\n\t\tsigs: [VECTOR, COMPRESSED_SIGNATURE],\n\t\tbitmap: BCS.U16,\n\t\tmultisig_pk: MULTISIG_PUBLIC_KEY,\n\t});\n/**\n * Utilities for better decoding.\n */\n\ntype ProgrammableCallInner = {\n\tpackage: string;\n\tmodule: string;\n\tfunction: string;\n\ttype_arguments: TypeTag[];\n\targuments: TransactionArgument[];\n};\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nbuilder.registerType(\n\t[ENUM_KIND, 'T'],\n\tfunction encode(this: BCS, writer, data: { kind: string }, typeParams, typeMap) {\n\t\tconst kind = data.kind;\n\t\tconst invariant = { [kind]: data };\n\t\tconst [enumType] = typeParams;\n\n\t\treturn this.getTypeInterface(enumType as string)._encodeRaw.call(\n\t\t\tthis,\n\t\t\twriter,\n\t\t\tinvariant,\n\t\t\ttypeParams,\n\t\t\ttypeMap,\n\t\t);\n\t},\n\tfunction decode(this: BCS, reader, typeParams, typeMap) {\n\t\tconst [enumType] = typeParams;\n\t\tconst data = this.getTypeInterface(enumType as string)._decodeRaw.call(\n\t\t\tthis,\n\t\t\treader,\n\t\t\ttypeParams,\n\t\t\ttypeMap,\n\t\t);\n\n\t\t// enum invariant can only have one `key` field\n\t\tconst kind = Object.keys(data)[0];\n\t\treturn { kind, ...data[kind] };\n\t},\n\t(data: { kind: string }) => {\n\t\tif (typeof data !== 'object' && !('kind' in data)) {\n\t\t\tthrow new Error(`EnumKind: Missing property \"kind\" in the input ${JSON.stringify(data)}`);\n\t\t}\n\n\t\treturn true;\n\t},\n);\n\n/**\n * Custom deserializer for the ProgrammableCall.\n *\n * Hides the inner structure and gives a simpler, more convenient\n * interface to encode and decode this struct as a part of `TransactionData`.\n *\n * - `(package)::(module)::(function)` are now `target` property.\n * - `TypeTag[]` array is now passed as strings, not as a struct.\n */\nbuilder.registerType(\n\tPROGRAMMABLE_CALL,\n\tfunction encodeProgrammableTx(this: BCS, writer, data: MoveCallTransaction, typeParams, typeMap) {\n\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t);\n\n\t\treturn this.getTypeInterface(PROGRAMMABLE_CALL_INNER)._encodeRaw.call(\n\t\t\tthis,\n\t\t\twriter,\n\t\t\t{\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t} as ProgrammableCallInner,\n\t\t\ttypeParams,\n\t\t\ttypeMap,\n\t\t);\n\t},\n\tfunction decodeProgrammableTx(this: BCS, reader, typeParams, typeMap) {\n\t\tlet data: ProgrammableCallInner = builder\n\t\t\t.getTypeInterface(PROGRAMMABLE_CALL_INNER)\n\t\t\t._decodeRaw.call(this, reader, typeParams, typeMap);\n\n\t\treturn {\n\t\t\ttarget: [data.package, data.module, data.function].join('::'),\n\t\t\targuments: data.arguments,\n\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t};\n\t},\n\t// Validation callback to error out if the data format is invalid.\n\t// TODO: make sure TypeTag can be parsed.\n\t(data: MoveCallTransaction) => {\n\t\treturn data.target.split('::').length === 3;\n\t},\n);\n\nfunction registerFixedArray(bcs: BCS, name: string, length: number) {\n\tbcs.registerType(\n\t\tname,\n\t\tfunction encode(this: BCS, writer, data, typeParams, typeMap) {\n\t\t\tif (data.length !== length) {\n\t\t\t\tthrow new Error(`Expected fixed array of length ${length}, got ${data.length}`);\n\t\t\t}\n\n\t\t\tif (typeParams.length !== 1) {\n\t\t\t\tthrow new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n\t\t\t}\n\n\t\t\tlet [type] = typeof typeParams[0] === 'string' ? [typeParams[0], []] : typeParams[0];\n\n\t\t\tfor (let piece of data) {\n\t\t\t\tthis.getTypeInterface(type)._encodeRaw.call(this, writer, piece, typeParams, typeMap);\n\t\t\t}\n\n\t\t\treturn writer;\n\t\t},\n\t\tfunction decode(this: BCS, reader, typeParams, typeMap) {\n\t\t\tif (typeParams.length !== 1) {\n\t\t\t\tthrow new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n\t\t\t}\n\n\t\t\tlet result: any = [];\n\t\t\tlet [type] = typeof typeParams[0] === 'string' ? [typeParams[0], []] : typeParams[0];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(this.getTypeInterface(type)._decodeRaw.call(this, reader, typeParams, typeMap));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\t);\n}\n"],
  "mappings": "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",
  "names": ["module", "bcs", "encode", "decode"]
}
