"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var common_exports = {};
__export(common_exports, {
  ObjectId: () => ObjectId,
  ObjectOwner: () => ObjectOwner,
  ProtocolConfig: () => ProtocolConfig,
  SUI_ADDRESS_LENGTH: () => SUI_ADDRESS_LENGTH,
  SequenceNumber: () => SequenceNumber,
  SuiAddress: () => SuiAddress,
  SuiJsonValue: () => SuiJsonValue,
  TransactionDigest: () => TransactionDigest,
  TransactionEffectsDigest: () => TransactionEffectsDigest,
  TransactionEventDigest: () => TransactionEventDigest,
  isValidSuiAddress: () => isValidSuiAddress,
  isValidSuiObjectId: () => isValidSuiObjectId,
  isValidTransactionDigest: () => isValidTransactionDigest,
  normalizeStructTag: () => normalizeStructTag,
  normalizeSuiAddress: () => normalizeSuiAddress,
  normalizeSuiObjectId: () => normalizeSuiObjectId,
  parseStructTag: () => parseStructTag
});
module.exports = __toCommonJS(common_exports);
var import_superstruct = require("superstruct");
var import_bcs = require("@mysten/bcs");
const TransactionDigest = (0, import_superstruct.string)();
const TransactionEffectsDigest = (0, import_superstruct.string)();
const TransactionEventDigest = (0, import_superstruct.string)();
const ObjectId = (0, import_superstruct.string)();
const SuiAddress = (0, import_superstruct.string)();
const SequenceNumber = (0, import_superstruct.string)();
const ObjectOwner = (0, import_superstruct.union)([
  (0, import_superstruct.object)({
    AddressOwner: SuiAddress
  }),
  (0, import_superstruct.object)({
    ObjectOwner: SuiAddress
  }),
  (0, import_superstruct.object)({
    Shared: (0, import_superstruct.object)({
      initial_shared_version: (0, import_superstruct.number)()
    })
  }),
  (0, import_superstruct.literal)("Immutable")
]);
const SuiJsonValue = (0, import_superstruct.define)("SuiJsonValue", () => true);
const ProtocolConfigValue = (0, import_superstruct.union)([
  (0, import_superstruct.object)({ u32: (0, import_superstruct.string)() }),
  (0, import_superstruct.object)({ u64: (0, import_superstruct.string)() }),
  (0, import_superstruct.object)({ f64: (0, import_superstruct.string)() })
]);
const ProtocolConfig = (0, import_superstruct.object)({
  attributes: (0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.nullable)(ProtocolConfigValue)),
  featureFlags: (0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.boolean)()),
  maxSupportedProtocolVersion: (0, import_superstruct.string)(),
  minSupportedProtocolVersion: (0, import_superstruct.string)(),
  protocolVersion: (0, import_superstruct.string)()
});
const TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = (0, import_bcs.fromB58)(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e) {
    return false;
  }
}
const SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function parseTypeTag(type) {
  if (!type.includes("::"))
    return type;
  return parseStructTag(type);
}
function parseStructTag(type) {
  const [address, module2] = type.split("::");
  const rest = type.slice(address.length + module2.length + 4);
  const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? (0, import_bcs.splitGenericParameters)(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: normalizeSuiAddress(address),
    module: module2,
    name,
    typeParams
  };
}
function normalizeStructTag(type) {
  const { address, module: module2, name, typeParams } = typeof type === "string" ? parseStructTag(type) : type;
  const formattedTypeParams = typeParams.length > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module2}::${name}${formattedTypeParams}`;
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}
//# sourceMappingURL=common.js.map
