// src/index.ts
export * from "@mysten/sui.js/utils";
export * from "@mysten/sui.js/transactions";

// src/suiKit.ts
import { getFullnodeUrl } from "@mysten/sui.js/client";
import { TransactionBlock as TransactionBlock2 } from "@mysten/sui.js/transactions";

// src/libs/suiAccountManager/index.ts
import { Ed25519Keypair as Ed25519Keypair2 } from "@mysten/sui.js/keypairs/ed25519";

// src/libs/suiAccountManager/keypair.ts
import { Ed25519Keypair } from "@mysten/sui.js/keypairs/ed25519";
var getDerivePathForSUI = (derivePathParams = {}) => {
  const {
    accountIndex = 0,
    isExternal = false,
    addressIndex = 0
  } = derivePathParams;
  return `m/44'/784'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;
};
var getKeyPair = (mnemonics, derivePathParams = {}) => {
  const derivePath = getDerivePathForSUI(derivePathParams);
  return Ed25519Keypair.deriveKeypair(mnemonics, derivePath);
};

// src/libs/suiAccountManager/util.ts
import { fromB64 } from "@mysten/sui.js/utils";
var isHex = (str) => /^0x[0-9a-fA-F]+$|^[0-9a-fA-F]+$/.test(str);
var isBase64 = (str) => /^[a-zA-Z0-9+/]+={0,2}$/g.test(str);
var fromHEX = (hexStr) => {
  if (!hexStr) {
    throw new Error("cannot parse empty string to Uint8Array");
  }
  const intArr = hexStr.replace("0x", "").match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16));
  if (!intArr || intArr.length === 0) {
    throw new Error(`Unable to parse HEX: ${hexStr}`);
  }
  return Uint8Array.from(intArr);
};
var hexOrBase64ToUint8Array = (str) => {
  if (isHex(str)) {
    return fromHEX(str);
  } else if (isBase64(str)) {
    return fromB64(str);
  } else {
    throw new Error("The string is not a valid hex or base64 string.");
  }
};
var PRIVATE_KEY_SIZE = 32;
var LEGACY_PRIVATE_KEY_SIZE = 64;
var normalizePrivateKey = (key) => {
  if (key.length === LEGACY_PRIVATE_KEY_SIZE) {
    key = key.slice(0, PRIVATE_KEY_SIZE);
  } else if (key.length === PRIVATE_KEY_SIZE + 1 && key[0] === 0) {
    return key.slice(1);
  } else if (key.length === PRIVATE_KEY_SIZE) {
    return key;
  }
  throw new Error("invalid secret key");
};

// src/libs/suiAccountManager/crypto.ts
import { generateMnemonic as genMnemonic } from "@scure/bip39";
import { wordlist } from "@scure/bip39/wordlists/english";
var generateMnemonic = (numberOfWords = 24) => {
  const strength = numberOfWords === 12 ? 128 : 256;
  return genMnemonic(wordlist, strength);
};

// src/libs/suiAccountManager/index.ts
import {
  SUI_PRIVATE_KEY_PREFIX,
  decodeSuiPrivateKey
} from "@mysten/sui.js/cryptography";
var SuiAccountManager = class {
  /**
   * Support the following ways to init the SuiToolkit:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string or Bech32 string, when mnemonics is provided, secretKey will be ignored
   */
  constructor({ mnemonics, secretKey } = {}) {
    this.mnemonics = mnemonics || "";
    this.secretKey = secretKey || "";
    if (!this.mnemonics && !this.secretKey) {
      this.mnemonics = generateMnemonic(24);
    }
    this.currentKeyPair = this.secretKey ? this.parseSecretKey(this.secretKey) : getKeyPair(this.mnemonics);
    this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();
  }
  /**
   * Check if the secretKey starts with bench32 format
   */
  parseSecretKey(secretKey) {
    if (secretKey.startsWith(SUI_PRIVATE_KEY_PREFIX)) {
      const { secretKey: uint8ArraySecretKey } = decodeSuiPrivateKey(secretKey);
      return Ed25519Keypair2.fromSecretKey(
        normalizePrivateKey(uint8ArraySecretKey)
      );
    }
    return Ed25519Keypair2.fromSecretKey(
      normalizePrivateKey(hexOrBase64ToUint8Array(secretKey))
    );
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.
   * else:
   * it will generate keyPair from the mnemonic with the given derivePathParams.
   */
  getKeyPair(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentKeyPair;
    return getKeyPair(this.mnemonics, derivePathParams);
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.
   * else:
   * it will generate address from the mnemonic with the given derivePathParams.
   */
  getAddress(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentAddress;
    return getKeyPair(this.mnemonics, derivePathParams).getPublicKey().toSuiAddress();
  }
  /**
   * Switch the current account with the given derivePathParams.
   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.
   */
  switchAccount(derivePathParams) {
    if (this.mnemonics) {
      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);
      this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();
    }
  }
};

// src/libs/suiTxBuilder/index.ts
import { TransactionBlock } from "@mysten/sui.js/transactions";
import { SUI_SYSTEM_STATE_OBJECT_ID } from "@mysten/sui.js/utils";

// src/libs/suiTxBuilder/util.ts
import {
  normalizeSuiObjectId,
  normalizeSuiAddress,
  isValidSuiObjectId,
  isValidSuiAddress
} from "@mysten/sui.js/utils";
import { Inputs } from "@mysten/sui.js/transactions";
import { isPureArg } from "@mysten/sui.js/bcs";
import { isSerializedBcs } from "@mysten/bcs";
var getDefaultSuiInputType = (value) => {
  if (typeof value === "string" && isValidSuiObjectId(value)) {
    return "object";
  } else if (typeof value === "number" || typeof value === "bigint") {
    return "u64";
  } else if (typeof value === "boolean") {
    return "bool";
  } else {
    return void 0;
  }
};
function makeVecParam(txBlock, args, type) {
  if (args.length === 0)
    throw new Error("Transaction builder error: Empty array is not allowed");
  const defaultSuiType = getDefaultSuiInputType(args[0]);
  const VECTOR_REGEX = /^vector<(.+)>$/;
  const STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
  type = type || defaultSuiType;
  if (type === "object") {
    const objects = args.map(
      (arg) => typeof arg === "string" && isValidSuiObjectId(arg) ? txBlock.object(normalizeSuiObjectId(arg)) : convertObjArg(txBlock, arg)
    );
    return txBlock.makeMoveVec({ objects });
  } else if (typeof type === "string" && !VECTOR_REGEX.test(type) && !STRUCT_REGEX.test(type)) {
    return txBlock.pure(args, `vector<${type}>`);
  } else {
    const objects = args.map(
      (arg) => convertObjArg(txBlock, arg)
    );
    return txBlock.makeMoveVec({ objects, type });
  }
}
function isMoveVecArg(arg) {
  if (typeof arg === "object" && "vecType" in arg && "value" in arg) {
    return true;
  } else if (Array.isArray(arg)) {
    return true;
  }
  return false;
}
function convertArgs(txBlock, args) {
  return args.map((arg) => {
    if (typeof arg === "string" && isValidSuiObjectId(arg)) {
      return txBlock.object(normalizeSuiObjectId(arg));
    } else if (typeof arg == "object" && !isSerializedBcs(arg) && !isPureArg(arg) && !isMoveVecArg(arg)) {
      return convertObjArg(txBlock, arg);
    } else if (isMoveVecArg(arg)) {
      const vecType = "vecType" in arg;
      return vecType ? makeVecParam(txBlock, arg.value, arg.vecType) : makeVecParam(txBlock, arg);
    } else if (isSerializedBcs(arg)) {
      return arg;
    } else {
      return txBlock.pure(arg);
    }
  });
}
function convertAddressArg(txBlock, arg) {
  if (typeof arg === "string" && isValidSuiAddress(arg)) {
    return txBlock.pure.address(normalizeSuiAddress(arg));
  } else if (typeof arg == "object" && !isSerializedBcs(arg) && !isPureArg(arg)) {
    return convertObjArg(txBlock, arg);
  } else if (isPureArg(arg)) {
    return txBlock.pure(arg);
  } else {
    return arg;
  }
}
function convertObjArg(txb, arg) {
  if (typeof arg === "string") {
    return txb.object(arg);
  }
  if ("digest" in arg && "version" in arg && "objectId" in arg) {
    return txb.objectRef(arg);
  }
  if ("objectId" in arg && "initialSharedVersion" in arg && "mutable" in arg) {
    return txb.sharedObjectRef(arg);
  }
  if ("Object" in arg) {
    if ("ImmOrOwned" in arg.Object) {
      return txb.object(Inputs.ObjectRef(arg.Object.ImmOrOwned));
    } else if ("Shared" in arg.Object) {
      return txb.object(Inputs.SharedObjectRef(arg.Object.Shared));
    } else {
      throw new Error("Invalid argument type");
    }
  }
  if ("kind" in arg) {
    return arg;
  }
  throw new Error("Invalid argument type");
}

// src/libs/suiTxBuilder/index.ts
var SuiTxBlock = class {
  constructor(transaction) {
    this.txBlock = new TransactionBlock(transaction);
  }
  /* Directly wrap methods and properties of TransactionBlock */
  get gas() {
    return this.txBlock.gas;
  }
  get blockData() {
    return this.txBlock.blockData;
  }
  address(value) {
    return this.txBlock.pure(value, "address");
  }
  pure(value, type) {
    return this.txBlock.pure(value, type);
  }
  object(value) {
    return this.txBlock.object(value);
  }
  objectRef(ref) {
    return this.txBlock.objectRef(ref);
  }
  sharedObjectRef(ref) {
    return this.txBlock.sharedObjectRef(ref);
  }
  setSender(sender) {
    return this.txBlock.setSender(sender);
  }
  setSenderIfNotSet(sender) {
    return this.txBlock.setSenderIfNotSet(sender);
  }
  setExpiration(expiration) {
    return this.txBlock.setExpiration(expiration);
  }
  setGasPrice(price) {
    return this.txBlock.setGasPrice(price);
  }
  setGasBudget(budget) {
    return this.txBlock.setGasBudget(budget);
  }
  setGasOwner(owner) {
    return this.txBlock.setGasOwner(owner);
  }
  setGasPayment(payments) {
    return this.txBlock.setGasPayment(payments);
  }
  serialize() {
    return this.txBlock.serialize();
  }
  sign(params) {
    return this.txBlock.sign(params);
  }
  build(params = {}) {
    return this.txBlock.build(params);
  }
  getDigest(params = {}) {
    return this.txBlock.getDigest(params);
  }
  add(...args) {
    return this.txBlock.add(...args);
  }
  publish({
    modules,
    dependencies
  }) {
    return this.txBlock.publish({ modules, dependencies });
  }
  upgrade({
    modules,
    dependencies,
    packageId,
    ticket
  }) {
    return this.txBlock.upgrade({ modules, dependencies, packageId, ticket });
  }
  makeMoveVec({
    objects,
    type
  }) {
    return this.txBlock.makeMoveVec({ objects, type });
  }
  /* Override methods of TransactionBlock */
  transferObjects(objects, address) {
    return this.txBlock.transferObjects(
      objects.map((object) => convertObjArg(this.txBlock, object)),
      convertAddressArg(this.txBlock, address)
    );
  }
  splitCoins(coin, amounts) {
    const res = this.txBlock.splitCoins(
      convertObjArg(this.txBlock, coin),
      convertArgs(this.txBlock, amounts)
    );
    return amounts.map((_, i) => res[i]);
  }
  mergeCoins(destination, sources) {
    const destinationObject = convertObjArg(this.txBlock, destination);
    const sourceObjects = sources.map(
      (source) => convertObjArg(this.txBlock, source)
    );
    return this.txBlock.mergeCoins(destinationObject, sourceObjects);
  }
  /**
   * @description Move call
   * @param target `${string}::${string}::${string}`, e.g. `0x3::sui_system::request_add_stake`
   * @param args the arguments of the move call, such as `['0x1', '0x2']`
   * @param typeArgs the type arguments of the move call, such as `['0x2::sui::SUI']`
   */
  moveCall(target, args = [], typeArgs = []) {
    const regex = /(?<package>[a-zA-Z0-9]+)::(?<module>[a-zA-Z0-9_]+)::(?<function>[a-zA-Z0-9_]+)/;
    const match = target.match(regex);
    if (match === null)
      throw new Error(
        "Invalid target format. Expected `${string}::${string}::${string}`"
      );
    const convertedArgs = convertArgs(this.txBlock, args);
    return this.txBlock.moveCall({
      target,
      arguments: convertedArgs,
      typeArguments: typeArgs
    });
  }
  /* Enhance methods of TransactionBlock */
  transferSuiToMany(recipients, amounts) {
    if (recipients.length !== amounts.length) {
      throw new Error(
        "transferSuiToMany: recipients.length !== amounts.length"
      );
    }
    const coins = this.txBlock.splitCoins(
      this.txBlock.gas,
      convertArgs(this.txBlock, amounts)
    );
    const recipientObjects = recipients.map(
      (recipient) => convertAddressArg(this.txBlock, recipient)
    );
    recipientObjects.forEach((address, index) => {
      this.txBlock.transferObjects([coins[index]], address);
    });
    return this;
  }
  transferSui(address, amount) {
    return this.transferSuiToMany([address], [amount]);
  }
  takeAmountFromCoins(coins, amount) {
    const coinObjects = coins.map((coin) => convertObjArg(this.txBlock, coin));
    const mergedCoin = coinObjects[0];
    if (coins.length > 1) {
      this.txBlock.mergeCoins(mergedCoin, coinObjects.slice(1));
    }
    const [sendCoin] = this.txBlock.splitCoins(
      mergedCoin,
      convertArgs(this.txBlock, [amount])
    );
    return [sendCoin, mergedCoin];
  }
  splitSUIFromGas(amounts) {
    return this.txBlock.splitCoins(
      this.txBlock.gas,
      convertArgs(this.txBlock, amounts)
    );
  }
  splitMultiCoins(coins, amounts) {
    const coinObjects = coins.map((coin) => convertObjArg(this.txBlock, coin));
    const mergedCoin = coinObjects[0];
    if (coins.length > 1) {
      this.txBlock.mergeCoins(mergedCoin, coinObjects.slice(1));
    }
    const splitedCoins = this.txBlock.splitCoins(
      mergedCoin,
      convertArgs(this.txBlock, amounts)
    );
    return { splitedCoins, mergedCoin };
  }
  transferCoinToMany(coins, sender, recipients, amounts) {
    if (recipients.length !== amounts.length) {
      throw new Error(
        "transferSuiToMany: recipients.length !== amounts.length"
      );
    }
    const coinObjects = coins.map((coin) => convertObjArg(this.txBlock, coin));
    const { splitedCoins, mergedCoin } = this.splitMultiCoins(
      coinObjects,
      amounts
    );
    const recipientObjects = recipients.map(
      (recipient) => convertAddressArg(this.txBlock, recipient)
    );
    recipientObjects.forEach((address, index) => {
      this.txBlock.transferObjects([splitedCoins[index]], address);
    });
    this.txBlock.transferObjects(
      [mergedCoin],
      convertAddressArg(this.txBlock, sender)
    );
    return this;
  }
  transferCoin(coins, sender, recipient, amount) {
    return this.transferCoinToMany(coins, sender, [recipient], [amount]);
  }
  stakeSui(amount, validatorAddr) {
    const [stakeCoin] = this.txBlock.splitCoins(
      this.txBlock.gas,
      convertArgs(this.txBlock, [amount])
    );
    return this.txBlock.moveCall({
      target: "0x3::sui_system::request_add_stake",
      arguments: convertArgs(this.txBlock, [
        SUI_SYSTEM_STATE_OBJECT_ID,
        stakeCoin,
        this.txBlock.pure(validatorAddr)
      ])
    });
  }
};

// src/libs/suiInteractor/suiInteractor.ts
import { SuiClient } from "@mysten/sui.js/client";

// src/libs/suiModel/suiOwnedObject.ts
var SuiOwnedObject = class {
  constructor(param) {
    this.objectId = param.objectId;
    this.version = param.version;
    this.digest = param.digest;
  }
  /**
   * Check if the object is fully initialized.
   * So that when it's used as an input, it won't be necessary to fetch from fullnode again.
   * Which can save time when sending transactions.
   */
  isFullObject() {
    return !!this.version && !!this.digest;
  }
  asCallArg() {
    if (!this.version || !this.digest) {
      return this.objectId;
    }
    return {
      Object: {
        ImmOrOwned: {
          objectId: this.objectId,
          version: this.version,
          digest: this.digest
        }
      }
    };
  }
  /**
   * Update object version & digest based on the transaction response.
   * @param txResponse
   */
  updateFromTxResponse(txResponse) {
    const changes = txResponse.objectChanges;
    if (!changes) {
      throw new Error("Bad transaction response!");
    }
    for (const change of changes) {
      if (change.type === "mutated" && change.objectId === this.objectId) {
        this.digest = change.digest;
        this.version = change.version;
        return;
      }
    }
    throw new Error("Could not find object in transaction response!");
  }
};

// src/libs/suiModel/suiSharedObject.ts
var SuiSharedObject = class {
  constructor(param) {
    this.objectId = param.objectId;
    this.initialSharedVersion = param.initialSharedVersion;
  }
  asCallArg(mutable = false) {
    if (!this.initialSharedVersion) {
      return this.objectId;
    }
    return {
      Object: {
        Shared: {
          objectId: this.objectId,
          initialSharedVersion: this.initialSharedVersion,
          mutable
        }
      }
    };
  }
};

// src/libs/suiInteractor/util.ts
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// src/libs/suiInteractor/suiInteractor.ts
var SuiInteractor = class {
  constructor(fullNodeUrls) {
    if (fullNodeUrls.length === 0)
      throw new Error("fullNodeUrls must not be empty");
    this.fullNodes = fullNodeUrls;
    this.clients = fullNodeUrls.map((url) => new SuiClient({ url }));
    this.currentFullNode = fullNodeUrls[0];
    this.currentClient = this.clients[0];
  }
  switchToNextClient() {
    const currentClientIdx = this.clients.indexOf(this.currentClient);
    this.currentClient = this.clients[(currentClientIdx + 1) % this.clients.length];
    this.currentFullNode = this.fullNodes[(currentClientIdx + 1) % this.clients.length];
  }
  async sendTx(transactionBlock, signature) {
    const txResOptions = {
      showEvents: true,
      showEffects: true,
      showObjectChanges: true,
      showBalanceChanges: true
    };
    for (const clientIdx in this.clients) {
      try {
        return await this.clients[clientIdx].executeTransactionBlock({
          transactionBlock,
          signature,
          options: txResOptions
        });
      } catch (err) {
        console.warn(
          `Failed to send transaction with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
        await delay(2e3);
      }
    }
    throw new Error("Failed to send transaction with all fullnodes");
  }
  async dryRunTx(transactionBlock) {
    for (const clientIdx in this.clients) {
      try {
        return await this.clients[clientIdx].dryRunTransactionBlock({
          transactionBlock
        });
      } catch (err) {
        console.warn(
          `Failed to dry run transaction with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
        await delay(2e3);
      }
    }
    throw new Error("Failed to dry run transaction with all fullnodes");
  }
  async getObjects(ids, options) {
    const opts = options ?? {
      showContent: true,
      showDisplay: true,
      showType: true,
      showOwner: true
    };
    for (const clientIdx in this.clients) {
      try {
        const objects = await this.clients[clientIdx].multiGetObjects({
          ids,
          options: opts
        });
        const parsedObjects = objects.map((object) => {
          return object.data;
        }).filter((object) => object !== null && object !== void 0);
        return parsedObjects;
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get objects with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
      }
    }
    throw new Error("Failed to get objects with all fullnodes");
  }
  async getObject(id, options) {
    const objects = await this.getObjects([id], options);
    return objects[0];
  }
  /**
   * @description Update objects in a batch
   * @param suiObjects
   */
  async updateObjects(suiObjects) {
    const objectIds = suiObjects.map((obj) => obj.objectId);
    const objects = await this.getObjects(objectIds);
    for (const object of objects) {
      const suiObject = suiObjects.find(
        (obj) => obj.objectId === object?.objectId
      );
      if (suiObject instanceof SuiSharedObject) {
        if (object.owner && typeof object.owner === "object" && "Shared" in object.owner) {
          suiObject.initialSharedVersion = object.owner.Shared.initial_shared_version;
        } else {
          suiObject.initialSharedVersion = void 0;
        }
      } else if (suiObject instanceof SuiOwnedObject) {
        suiObject.version = object?.version;
        suiObject.digest = object?.digest;
      }
    }
  }
  /**
   * @description Select coins that add up to the given amount.
   * @param addr the address of the owner
   * @param amount the amount that is needed for the coin
   * @param coinType the coin type, default is '0x2::SUI::SUI'
   */
  async selectCoins(addr, amount, coinType = "0x2::SUI::SUI") {
    const selectedCoins = [];
    let totalAmount = 0;
    let hasNext = true, nextCursor = null;
    while (hasNext && totalAmount < amount) {
      const coins = await this.currentClient.getCoins({
        owner: addr,
        coinType,
        cursor: nextCursor
      });
      coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));
      for (const coinData of coins.data) {
        selectedCoins.push({
          objectId: coinData.coinObjectId,
          digest: coinData.digest,
          version: coinData.version
        });
        totalAmount = totalAmount + parseInt(coinData.balance);
        if (totalAmount >= amount) {
          break;
        }
      }
      nextCursor = coins.nextCursor;
      hasNext = coins.hasNextPage;
    }
    if (!selectedCoins.length) {
      throw new Error("No valid coins found for the transaction.");
    }
    return selectedCoins;
  }
};

// src/suiKit.ts
var SuiKit = class {
  /**
   * Support the following ways to init the SuiToolkit:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string or bech32, when mnemonics is provided, secretKey will be ignored
   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'mainnet'
   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type
   */
  constructor({
    mnemonics,
    secretKey,
    networkType,
    fullnodeUrls
  } = {}) {
    this.accountManager = new SuiAccountManager({ mnemonics, secretKey });
    fullnodeUrls = fullnodeUrls || [getFullnodeUrl(networkType ?? "mainnet")];
    this.suiInteractor = new SuiInteractor(fullnodeUrls);
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the keypair.
   * else:
   * it will generate signer from the mnemonic with the given derivePathParams.
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getKeypair(derivePathParams) {
    return this.accountManager.getKeyPair(derivePathParams);
  }
  /**
   * @description Switch the current account with the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  switchAccount(derivePathParams) {
    this.accountManager.switchAccount(derivePathParams);
  }
  /**
   * @description Get the address of the account for the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getAddress(derivePathParams) {
    return this.accountManager.getAddress(derivePathParams);
  }
  currentAddress() {
    return this.accountManager.currentAddress;
  }
  async getBalance(coinType, derivePathParams) {
    const owner = this.accountManager.getAddress(derivePathParams);
    return this.suiInteractor.currentClient.getBalance({ owner, coinType });
  }
  client() {
    return this.suiInteractor.currentClient;
  }
  async getObjects(objectIds, options) {
    return this.suiInteractor.getObjects(objectIds, options);
  }
  /**
   * @description Update objects in a batch
   * @param suiObjects
   */
  async updateObjects(suiObjects) {
    return this.suiInteractor.updateObjects(suiObjects);
  }
  async signTxn(tx, derivePathParams) {
    if (tx instanceof SuiTxBlock) {
      tx.setSender(this.getAddress(derivePathParams));
    }
    const txBlock = tx instanceof SuiTxBlock ? tx.txBlock : tx;
    const txBytes = txBlock instanceof TransactionBlock2 ? await txBlock.build({ client: this.client() }) : txBlock;
    const keyPair = this.getKeypair(derivePathParams);
    return await keyPair.signTransactionBlock(txBytes);
  }
  async signAndSendTxn(tx, derivePathParams) {
    const { bytes, signature } = await this.signTxn(tx, derivePathParams);
    return this.suiInteractor.sendTx(bytes, signature);
  }
  async dryRunTxn(tx, derivePathParams) {
    if (tx instanceof SuiTxBlock) {
      tx.setSender(this.getAddress(derivePathParams));
    }
    const txBlock = tx instanceof SuiTxBlock ? tx.txBlock : tx;
    const txBytes = txBlock instanceof TransactionBlock2 ? await txBlock.build({ client: this.client() }) : txBlock;
    return this.suiInteractor.dryRunTx(txBytes);
  }
  /**
   * Transfer the given amount of SUI to the recipient
   * @param recipient
   * @param amount
   * @param derivePathParams
   */
  async transferSui(recipient, amount, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.transferSui(recipient, amount);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Transfer to mutliple recipients
   * @param recipients the recipients addresses
   * @param amounts the amounts of SUI to transfer to each recipient, the length of amounts should be the same as the length of recipients
   * @param derivePathParams
   */
  async transferSuiToMany(recipients, amounts, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.transferSuiToMany(recipients, amounts);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Transfer the given amounts of coin to multiple recipients
   * @param recipients the list of recipient address
   * @param amounts the amounts to transfer for each recipient
   * @param coinType any custom coin type but not SUI
   * @param derivePathParams the derive path params for the current signer
   */
  async transferCoinToMany(recipients, amounts, coinType, derivePathParams) {
    const tx = new SuiTxBlock();
    const owner = this.accountManager.getAddress(derivePathParams);
    const totalAmount = amounts.reduce((a, b) => a + b, 0);
    const coins = await this.suiInteractor.selectCoins(
      owner,
      totalAmount,
      coinType
    );
    tx.transferCoinToMany(
      coins.map((c) => c.objectId),
      owner,
      recipients,
      amounts
    );
    return this.signAndSendTxn(tx, derivePathParams);
  }
  async transferCoin(recipient, amount, coinType, derivePathParams) {
    return this.transferCoinToMany(
      [recipient],
      [amount],
      coinType,
      derivePathParams
    );
  }
  async transferObjects(objects, recipient, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.transferObjects(objects, recipient);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  async moveCall(callParams) {
    const {
      target,
      arguments: args = [],
      typeArguments = [],
      derivePathParams
    } = callParams;
    const tx = new SuiTxBlock();
    tx.moveCall(target, args, typeArguments);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Select coins with the given amount and coin type, the total amount is greater than or equal to the given amount
   * @param amount
   * @param coinType
   * @param owner
   */
  async selectCoinsWithAmount(amount, coinType, owner) {
    owner = owner || this.accountManager.currentAddress;
    const coins = await this.suiInteractor.selectCoins(owner, amount, coinType);
    return coins.map((c) => c.objectId);
  }
  /**
   * stake the given amount of SUI to the validator
   * @param amount the amount of SUI to stake
   * @param validatorAddr the validator address
   * @param derivePathParams the derive path params for the current signer
   */
  async stakeSui(amount, validatorAddr, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.stakeSui(amount, validatorAddr);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Execute the transaction with on-chain data but without really submitting. Useful for querying the effects of a transaction.
   * Since the transaction is not submitted, its gas cost is not charged.
   * @param tx the transaction to execute
   * @param derivePathParams the derive path params
   * @returns the effects and events of the transaction, such as object changes, gas cost, event emitted.
   */
  async inspectTxn(tx, derivePathParams) {
    const txBlock = tx instanceof SuiTxBlock ? tx.txBlock : tx;
    return this.suiInteractor.currentClient.devInspectTransactionBlock({
      transactionBlock: txBlock,
      sender: this.getAddress(derivePathParams)
    });
  }
};

// src/libs/multiSig/client.ts
import { MultiSigPublicKey } from "@mysten/sui.js/multisig";

// src/libs/multiSig/publickey.ts
import { Ed25519PublicKey } from "@mysten/sui.js/keypairs/ed25519";
import { fromB64 as fromB642 } from "@mysten/sui.js/utils";
function ed25519PublicKeyFromBase64(rawPubkey) {
  let bytes = fromB642(rawPubkey);
  if (bytes.length !== 32 && bytes.length !== 33)
    throw "invalid pubkey length";
  bytes = bytes.length === 33 ? bytes.slice(1) : bytes;
  return new Ed25519PublicKey(bytes);
}

// src/libs/multiSig/client.ts
var MultiSigClient = class _MultiSigClient {
  constructor(pks, threshold) {
    this.pksWeightPairs = pks;
    this.threshold = threshold;
    this.multiSigPublicKey = MultiSigPublicKey.fromPublicKeys({
      threshold: this.threshold,
      publicKeys: this.pksWeightPairs
    });
  }
  static fromRawEd25519PublicKeys(rawPublicKeys, weights, threshold) {
    const pks = rawPublicKeys.map((rawPublicKey, i) => {
      return {
        publicKey: ed25519PublicKeyFromBase64(rawPublicKey),
        weight: weights[i]
      };
    });
    return new _MultiSigClient(pks, threshold);
  }
  multiSigAddress() {
    return this.multiSigPublicKey.toSuiAddress();
  }
  combinePartialSigs(sigs) {
    return this.multiSigPublicKey.combinePartialSignatures(sigs);
  }
};
export {
  MultiSigClient,
  SuiAccountManager,
  SuiKit,
  SuiTxBlock
};
//# sourceMappingURL=index.mjs.map