{"version":3,"sources":["../src/index.ts","../src/suiKit.ts","../src/libs/suiAccountManager/index.ts","../src/libs/suiAccountManager/keypair.ts","../src/libs/suiAccountManager/util.ts","../src/libs/suiAccountManager/crypto.ts","../src/libs/suiTxBuilder/index.ts","../src/libs/suiTxBuilder/util.ts","../src/libs/suiInteractor/suiInteractor.ts","../src/libs/suiModel/suiOwnedObject.ts","../src/libs/suiModel/suiSharedObject.ts","../src/libs/suiInteractor/util.ts","../src/libs/multiSig/client.ts","../src/libs/multiSig/publickey.ts"],"sourcesContent":["export * from '@mysten/sui.js/utils';\nexport * from '@mysten/sui.js/transactions';\nexport { SuiKit } from './suiKit';\nexport { SuiAccountManager } from './libs/suiAccountManager';\nexport { SuiTxBlock } from './libs/suiTxBuilder';\nexport { MultiSigClient } from './libs/multiSig';\nexport type * from './types';\n","/**\n * @description This file is used to aggregate the tools that used to interact with SUI network.\n */\nimport { getFullnodeUrl } from '@mysten/sui.js/client';\nimport { TransactionBlock } from '@mysten/sui.js/transactions';\nimport { SuiAccountManager } from './libs/suiAccountManager';\nimport { SuiTxBlock } from './libs/suiTxBuilder';\nimport { SuiInteractor } from './libs/suiInteractor';\nimport type {\n  SuiTransactionBlockResponse,\n  DevInspectResults,\n  SuiObjectDataOptions,\n  DryRunTransactionBlockResponse,\n} from '@mysten/sui.js/client';\nimport type { SuiSharedObject, SuiOwnedObject } from './libs/suiModel';\nimport type {\n  SuiKitParams,\n  DerivePathParams,\n  SuiTxArg,\n  SuiVecTxArg,\n} from './types';\n\n/**\n * @class SuiKit\n * @description This class is used to aggregate the tools that used to interact with SUI network.\n */\nexport class SuiKit {\n  public accountManager: SuiAccountManager;\n  public suiInteractor: SuiInteractor;\n\n  /**\n   * Support the following ways to init the SuiToolkit:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string or bech32, when mnemonics is provided, secretKey will be ignored\n   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'mainnet'\n   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type\n   */\n  constructor({\n    mnemonics,\n    secretKey,\n    networkType,\n    fullnodeUrls,\n  }: SuiKitParams = {}) {\n    // Init the account manager\n    this.accountManager = new SuiAccountManager({ mnemonics, secretKey });\n    // Init the sui interactor\n    fullnodeUrls = fullnodeUrls || [getFullnodeUrl(networkType ?? 'mainnet')];\n    this.suiInteractor = new SuiInteractor(fullnodeUrls);\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the keypair.\n   * else:\n   * it will generate signer from the mnemonic with the given derivePathParams.\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getKeypair(derivePathParams?: DerivePathParams) {\n    return this.accountManager.getKeyPair(derivePathParams);\n  }\n\n  /**\n   * @description Switch the current account with the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  switchAccount(derivePathParams: DerivePathParams) {\n    this.accountManager.switchAccount(derivePathParams);\n  }\n\n  /**\n   * @description Get the address of the account for the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    return this.accountManager.getAddress(derivePathParams);\n  }\n\n  currentAddress() {\n    return this.accountManager.currentAddress;\n  }\n\n  async getBalance(coinType?: string, derivePathParams?: DerivePathParams) {\n    const owner = this.accountManager.getAddress(derivePathParams);\n    return this.suiInteractor.currentClient.getBalance({ owner, coinType });\n  }\n\n  client() {\n    return this.suiInteractor.currentClient;\n  }\n\n  async getObjects(objectIds: string[], options?: SuiObjectDataOptions) {\n    return this.suiInteractor.getObjects(objectIds, options);\n  }\n\n  /**\n   * @description Update objects in a batch\n   * @param suiObjects\n   */\n  async updateObjects(suiObjects: (SuiSharedObject | SuiOwnedObject)[]) {\n    return this.suiInteractor.updateObjects(suiObjects);\n  }\n\n  async signTxn(\n    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n    derivePathParams?: DerivePathParams\n  ) {\n    if (tx instanceof SuiTxBlock) {\n      tx.setSender(this.getAddress(derivePathParams));\n    }\n    const txBlock = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    const txBytes =\n      txBlock instanceof TransactionBlock\n        ? await txBlock.build({ client: this.client() })\n        : txBlock;\n    const keyPair = this.getKeypair(derivePathParams);\n    return await keyPair.signTransactionBlock(txBytes);\n  }\n\n  async signAndSendTxn(\n    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n    derivePathParams?: DerivePathParams\n  ): Promise<SuiTransactionBlockResponse> {\n    const { bytes, signature } = await this.signTxn(tx, derivePathParams);\n    return this.suiInteractor.sendTx(bytes, signature);\n  }\n\n  async dryRunTxn(\n    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n    derivePathParams?: DerivePathParams\n  ): Promise<DryRunTransactionBlockResponse> {\n    if (tx instanceof SuiTxBlock) {\n      tx.setSender(this.getAddress(derivePathParams));\n    }\n    const txBlock = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    const txBytes =\n      txBlock instanceof TransactionBlock\n        ? await txBlock.build({ client: this.client() })\n        : txBlock;\n    return this.suiInteractor.dryRunTx(txBytes);\n  }\n\n  /**\n   * Transfer the given amount of SUI to the recipient\n   * @param recipient\n   * @param amount\n   * @param derivePathParams\n   */\n  async transferSui(\n    recipient: string,\n    amount: number,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.transferSui(recipient, amount);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Transfer to mutliple recipients\n   * @param recipients the recipients addresses\n   * @param amounts the amounts of SUI to transfer to each recipient, the length of amounts should be the same as the length of recipients\n   * @param derivePathParams\n   */\n  async transferSuiToMany(\n    recipients: string[],\n    amounts: number[],\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.transferSuiToMany(recipients, amounts);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Transfer the given amounts of coin to multiple recipients\n   * @param recipients the list of recipient address\n   * @param amounts the amounts to transfer for each recipient\n   * @param coinType any custom coin type but not SUI\n   * @param derivePathParams the derive path params for the current signer\n   */\n  async transferCoinToMany(\n    recipients: string[],\n    amounts: number[],\n    coinType: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    const owner = this.accountManager.getAddress(derivePathParams);\n    const totalAmount = amounts.reduce((a, b) => a + b, 0);\n    const coins = await this.suiInteractor.selectCoins(\n      owner,\n      totalAmount,\n      coinType\n    );\n    tx.transferCoinToMany(\n      coins.map((c) => c.objectId),\n      owner,\n      recipients,\n      amounts\n    );\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  async transferCoin(\n    recipient: string,\n    amount: number,\n    coinType: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    return this.transferCoinToMany(\n      [recipient],\n      [amount],\n      coinType,\n      derivePathParams\n    );\n  }\n\n  async transferObjects(\n    objects: string[],\n    recipient: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.transferObjects(objects, recipient);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  async moveCall(callParams: {\n    target: string;\n    arguments?: (SuiTxArg | SuiVecTxArg)[];\n    typeArguments?: string[];\n    derivePathParams?: DerivePathParams;\n  }) {\n    const {\n      target,\n      arguments: args = [],\n      typeArguments = [],\n      derivePathParams,\n    } = callParams;\n    const tx = new SuiTxBlock();\n    tx.moveCall(target, args, typeArguments);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Select coins with the given amount and coin type, the total amount is greater than or equal to the given amount\n   * @param amount\n   * @param coinType\n   * @param owner\n   */\n  async selectCoinsWithAmount(\n    amount: number,\n    coinType: string,\n    owner?: string\n  ) {\n    owner = owner || this.accountManager.currentAddress;\n    const coins = await this.suiInteractor.selectCoins(owner, amount, coinType);\n    return coins.map((c) => c.objectId);\n  }\n\n  /**\n   * stake the given amount of SUI to the validator\n   * @param amount the amount of SUI to stake\n   * @param validatorAddr the validator address\n   * @param derivePathParams the derive path params for the current signer\n   */\n  async stakeSui(\n    amount: number,\n    validatorAddr: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.stakeSui(amount, validatorAddr);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Execute the transaction with on-chain data but without really submitting. Useful for querying the effects of a transaction.\n   * Since the transaction is not submitted, its gas cost is not charged.\n   * @param tx the transaction to execute\n   * @param derivePathParams the derive path params\n   * @returns the effects and events of the transaction, such as object changes, gas cost, event emitted.\n   */\n  async inspectTxn(\n    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n    derivePathParams?: DerivePathParams\n  ): Promise<DevInspectResults> {\n    const txBlock = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    return this.suiInteractor.currentClient.devInspectTransactionBlock({\n      transactionBlock: txBlock,\n      sender: this.getAddress(derivePathParams),\n    });\n  }\n}\n","import { Ed25519Keypair } from '@mysten/sui.js/keypairs/ed25519';\nimport { getKeyPair } from './keypair';\nimport { hexOrBase64ToUint8Array, normalizePrivateKey } from './util';\nimport { generateMnemonic } from './crypto';\nimport type { AccountMangerParams, DerivePathParams } from 'src/types';\nimport {\n  SUI_PRIVATE_KEY_PREFIX,\n  decodeSuiPrivateKey,\n} from '@mysten/sui.js/cryptography';\n\nexport class SuiAccountManager {\n  private mnemonics: string;\n  private secretKey: string;\n  public currentKeyPair: Ed25519Keypair;\n  public currentAddress: string;\n\n  /**\n   * Support the following ways to init the SuiToolkit:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string or Bech32 string, when mnemonics is provided, secretKey will be ignored\n   */\n  constructor({ mnemonics, secretKey }: AccountMangerParams = {}) {\n    // If the mnemonics or secretKey is provided, use it\n    // Otherwise, generate a random mnemonics with 24 words\n    this.mnemonics = mnemonics || '';\n    this.secretKey = secretKey || '';\n    if (!this.mnemonics && !this.secretKey) {\n      this.mnemonics = generateMnemonic(24);\n    }\n\n    // Init the current account\n    this.currentKeyPair = this.secretKey\n      ? this.parseSecretKey(this.secretKey)\n      : getKeyPair(this.mnemonics);\n    this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n  }\n\n  /**\n   * Check if the secretKey starts with bench32 format\n   */\n  parseSecretKey(secretKey: string) {\n    if (secretKey.startsWith(SUI_PRIVATE_KEY_PREFIX)) {\n      const { secretKey: uint8ArraySecretKey } = decodeSuiPrivateKey(secretKey);\n      return Ed25519Keypair.fromSecretKey(\n        normalizePrivateKey(uint8ArraySecretKey)\n      );\n    }\n\n    return Ed25519Keypair.fromSecretKey(\n      normalizePrivateKey(hexOrBase64ToUint8Array(secretKey))\n    );\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.\n   * else:\n   * it will generate keyPair from the mnemonic with the given derivePathParams.\n   */\n  getKeyPair(derivePathParams?: DerivePathParams) {\n    if (!derivePathParams || !this.mnemonics) return this.currentKeyPair;\n    return getKeyPair(this.mnemonics, derivePathParams);\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.\n   * else:\n   * it will generate address from the mnemonic with the given derivePathParams.\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    if (!derivePathParams || !this.mnemonics) return this.currentAddress;\n    return getKeyPair(this.mnemonics, derivePathParams)\n      .getPublicKey()\n      .toSuiAddress();\n  }\n\n  /**\n   * Switch the current account with the given derivePathParams.\n   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.\n   */\n  switchAccount(derivePathParams: DerivePathParams) {\n    if (this.mnemonics) {\n      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);\n      this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n    }\n  }\n}\n","import { Ed25519Keypair } from '@mysten/sui.js/keypairs/ed25519';\nimport type { DerivePathParams } from 'src/types';\n\n/**\n * @description Get ed25519 derive path for SUI\n * @param derivePathParams\n */\nexport const getDerivePathForSUI = (\n  derivePathParams: DerivePathParams = {}\n) => {\n  const {\n    accountIndex = 0,\n    isExternal = false,\n    addressIndex = 0,\n  } = derivePathParams;\n  return `m/44'/784'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;\n};\n\n/**\n * the format is m/44'/784'/accountIndex'/${isExternal ? 1 : 0}'/addressIndex'\n *\n * accountIndex is the index of the account, default is 0.\n *\n * isExternal is the type of the address, default is false. Usually, the external address is used to receive coins. The internal address is used to change coins.\n *\n * addressIndex is the index of the address, default is 0. It's used to generate multiple addresses for one account.\n *\n * @description Get keypair from mnemonics and derive path\n * @param mnemonics\n * @param derivePathParams\n */\nexport const getKeyPair = (\n  mnemonics: string,\n  derivePathParams: DerivePathParams = {}\n) => {\n  const derivePath = getDerivePathForSUI(derivePathParams);\n  return Ed25519Keypair.deriveKeypair(mnemonics, derivePath);\n};\n","import { fromB64 } from '@mysten/sui.js/utils';\n\n/**\n * @description This regular expression matches any string that contains only hexadecimal digits (0-9, A-F, a-f).\n * @param str\n */\nexport const isHex = (str: string) =>\n  /^0x[0-9a-fA-F]+$|^[0-9a-fA-F]+$/.test(str);\n\n/**\n * @description This regular expression matches any string that contains only base64 digits (0-9, A-Z, a-z, +, /, =).\n * Note that the \"=\" signs at the end are optional padding characters that may be present in some base64 encoded strings.\n * @param str\n */\nexport const isBase64 = (str: string) => /^[a-zA-Z0-9+/]+={0,2}$/g.test(str);\n\n/**\n * Convert a hex string to Uint8Array\n * @param hexStr\n */\nexport const fromHEX = (hexStr: string): Uint8Array => {\n  if (!hexStr) {\n    throw new Error('cannot parse empty string to Uint8Array');\n  }\n  const intArr = hexStr\n    .replace('0x', '')\n    .match(/.{1,2}/g)\n    ?.map((byte) => parseInt(byte, 16));\n\n  if (!intArr || intArr.length === 0) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n};\n\n/**\n * @description Convert a hex or base64 string to Uint8Array\n */\nexport const hexOrBase64ToUint8Array = (str: string): Uint8Array => {\n  if (isHex(str)) {\n    return fromHEX(str);\n  } else if (isBase64(str)) {\n    return fromB64(str);\n  } else {\n    throw new Error('The string is not a valid hex or base64 string.');\n  }\n};\n\nconst PRIVATE_KEY_SIZE = 32;\nconst LEGACY_PRIVATE_KEY_SIZE = 64;\n/**\n * normalize a private key\n * A private key is a 32-byte array.\n * But there are two different formats for private keys:\n * 1. A 32-byte array\n * 2. A 64-byte array with the first 32 bytes being the private key and the last 32 bytes being the public key\n * 3. A 33-byte array with the first byte being 0x00 (sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning)\n */\nexport const normalizePrivateKey = (key: Uint8Array): Uint8Array => {\n  if (key.length === LEGACY_PRIVATE_KEY_SIZE) {\n    // This is a legacy secret key, we need to strip the public key bytes and only read the first 32 bytes\n    key = key.slice(0, PRIVATE_KEY_SIZE);\n  } else if (key.length === PRIVATE_KEY_SIZE + 1 && key[0] === 0) {\n    // sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning\n    return key.slice(1);\n  } else if (key.length === PRIVATE_KEY_SIZE) {\n    return key;\n  }\n  throw new Error('invalid secret key');\n};\n","import { generateMnemonic as genMnemonic } from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\n\nexport const generateMnemonic = (numberOfWords: 12 | 24 = 24) => {\n  const strength = numberOfWords === 12 ? 128 : 256;\n  return genMnemonic(wordlist, strength);\n};\n","import { TransactionBlock } from '@mysten/sui.js/transactions';\nimport { SUI_SYSTEM_STATE_OBJECT_ID } from '@mysten/sui.js/utils';\nimport { convertArgs, convertAddressArg, convertObjArg } from './util';\nimport type { SuiClient, SuiObjectRef } from '@mysten/sui.js/client';\nimport type { TransactionObjectArgument } from '@mysten/sui.js/transactions';\nimport type {\n  TransactionExpiration,\n  SharedObjectRef,\n} from '@mysten/sui.js/bcs';\nimport type { Keypair } from '@mysten/sui.js/cryptography';\nimport type {\n  ObjectCallArg,\n  TransactionType,\n  SuiTxArg,\n  SuiAddressArg,\n  SuiObjectArg,\n  SuiVecTxArg,\n} from 'src/types';\n\nexport class SuiTxBlock {\n  public txBlock: TransactionBlock;\n\n  constructor(transaction?: TransactionBlock) {\n    this.txBlock = new TransactionBlock(transaction);\n  }\n\n  /* Directly wrap methods and properties of TransactionBlock */\n  get gas() {\n    return this.txBlock.gas;\n  }\n  get blockData() {\n    return this.txBlock.blockData;\n  }\n\n  address(value: string) {\n    return this.txBlock.pure(value, 'address');\n  }\n  pure(value: unknown, type?: string) {\n    return this.txBlock.pure(value, type);\n  }\n  object(value: string | ObjectCallArg) {\n    return this.txBlock.object(value);\n  }\n  objectRef(ref: SuiObjectRef) {\n    return this.txBlock.objectRef(ref);\n  }\n  sharedObjectRef(ref: SharedObjectRef) {\n    return this.txBlock.sharedObjectRef(ref);\n  }\n  setSender(sender: string) {\n    return this.txBlock.setSender(sender);\n  }\n  setSenderIfNotSet(sender: string) {\n    return this.txBlock.setSenderIfNotSet(sender);\n  }\n  setExpiration(expiration?: TransactionExpiration) {\n    return this.txBlock.setExpiration(expiration);\n  }\n  setGasPrice(price: number | bigint) {\n    return this.txBlock.setGasPrice(price);\n  }\n  setGasBudget(budget: number | bigint) {\n    return this.txBlock.setGasBudget(budget);\n  }\n  setGasOwner(owner: string) {\n    return this.txBlock.setGasOwner(owner);\n  }\n  setGasPayment(payments: SuiObjectRef[]) {\n    return this.txBlock.setGasPayment(payments);\n  }\n  serialize() {\n    return this.txBlock.serialize();\n  }\n  sign(params: {\n    signer: Keypair;\n    client?: SuiClient;\n    onlyTransactionKind?: boolean;\n  }) {\n    return this.txBlock.sign(params);\n  }\n  build(\n    params: {\n      client?: SuiClient;\n      onlyTransactionKind?: boolean;\n    } = {}\n  ) {\n    return this.txBlock.build(params);\n  }\n  getDigest(params: { client?: SuiClient } = {}) {\n    return this.txBlock.getDigest(params);\n  }\n  add(...args: TransactionType) {\n    return this.txBlock.add(...args);\n  }\n  publish({\n    modules,\n    dependencies,\n  }: {\n    modules: number[][] | string[];\n    dependencies: string[];\n  }) {\n    return this.txBlock.publish({ modules, dependencies });\n  }\n  upgrade({\n    modules,\n    dependencies,\n    packageId,\n    ticket,\n  }: {\n    modules: number[][] | string[];\n    dependencies: string[];\n    packageId: string;\n    ticket: TransactionObjectArgument | string;\n  }) {\n    return this.txBlock.upgrade({ modules, dependencies, packageId, ticket });\n  }\n  makeMoveVec({\n    objects,\n    type,\n  }: {\n    objects: (TransactionObjectArgument | string)[];\n    type?: string;\n  }) {\n    return this.txBlock.makeMoveVec({ objects, type });\n  }\n\n  /* Override methods of TransactionBlock */\n\n  transferObjects(objects: SuiObjectArg[], address: SuiAddressArg) {\n    return this.txBlock.transferObjects(\n      objects.map((object) => convertObjArg(this.txBlock, object)),\n      convertAddressArg(this.txBlock, address)\n    );\n  }\n\n  splitCoins(coin: SuiObjectArg, amounts: SuiTxArg[]) {\n    const res = this.txBlock.splitCoins(\n      convertObjArg(this.txBlock, coin),\n      convertArgs(this.txBlock, amounts)\n    );\n    return amounts.map((_, i) => res[i]);\n  }\n\n  mergeCoins(destination: SuiObjectArg, sources: SuiObjectArg[]) {\n    const destinationObject = convertObjArg(this.txBlock, destination);\n    const sourceObjects = sources.map((source) =>\n      convertObjArg(this.txBlock, source)\n    );\n    return this.txBlock.mergeCoins(destinationObject, sourceObjects);\n  }\n\n  /**\n   * @description Move call\n   * @param target `${string}::${string}::${string}`, e.g. `0x3::sui_system::request_add_stake`\n   * @param args the arguments of the move call, such as `['0x1', '0x2']`\n   * @param typeArgs the type arguments of the move call, such as `['0x2::sui::SUI']`\n   */\n  moveCall(\n    target: string,\n    args: (SuiTxArg | SuiVecTxArg)[] = [],\n    typeArgs: string[] = []\n  ) {\n    // a regex for pattern `${string}::${string}::${string}`\n    const regex =\n      /(?<package>[a-zA-Z0-9]+)::(?<module>[a-zA-Z0-9_]+)::(?<function>[a-zA-Z0-9_]+)/;\n    const match = target.match(regex);\n    if (match === null)\n      throw new Error(\n        'Invalid target format. Expected `${string}::${string}::${string}`'\n      );\n    const convertedArgs = convertArgs(this.txBlock, args);\n    return this.txBlock.moveCall({\n      target: target as `${string}::${string}::${string}`,\n      arguments: convertedArgs,\n      typeArguments: typeArgs,\n    });\n  }\n\n  /* Enhance methods of TransactionBlock */\n\n  transferSuiToMany(recipients: SuiAddressArg[], amounts: SuiTxArg[]) {\n    // require recipients.length === amounts.length\n    if (recipients.length !== amounts.length) {\n      throw new Error(\n        'transferSuiToMany: recipients.length !== amounts.length'\n      );\n    }\n    const coins = this.txBlock.splitCoins(\n      this.txBlock.gas,\n      convertArgs(this.txBlock, amounts)\n    );\n    const recipientObjects = recipients.map((recipient) =>\n      convertAddressArg(this.txBlock, recipient)\n    );\n    recipientObjects.forEach((address, index) => {\n      this.txBlock.transferObjects([coins[index]], address);\n    });\n    return this;\n  }\n\n  transferSui(address: SuiAddressArg, amount: SuiTxArg) {\n    return this.transferSuiToMany([address], [amount]);\n  }\n\n  takeAmountFromCoins(coins: SuiObjectArg[], amount: SuiTxArg) {\n    const coinObjects = coins.map((coin) => convertObjArg(this.txBlock, coin));\n    const mergedCoin = coinObjects[0];\n    if (coins.length > 1) {\n      this.txBlock.mergeCoins(mergedCoin, coinObjects.slice(1));\n    }\n    const [sendCoin] = this.txBlock.splitCoins(\n      mergedCoin,\n      convertArgs(this.txBlock, [amount])\n    );\n    return [sendCoin, mergedCoin];\n  }\n\n  splitSUIFromGas(amounts: SuiTxArg[]) {\n    return this.txBlock.splitCoins(\n      this.txBlock.gas,\n      convertArgs(this.txBlock, amounts)\n    );\n  }\n\n  splitMultiCoins(coins: SuiObjectArg[], amounts: SuiTxArg[]) {\n    const coinObjects = coins.map((coin) => convertObjArg(this.txBlock, coin));\n    const mergedCoin = coinObjects[0];\n    if (coins.length > 1) {\n      this.txBlock.mergeCoins(mergedCoin, coinObjects.slice(1));\n    }\n    const splitedCoins = this.txBlock.splitCoins(\n      mergedCoin,\n      convertArgs(this.txBlock, amounts)\n    );\n    return { splitedCoins, mergedCoin };\n  }\n\n  transferCoinToMany(\n    coins: SuiObjectArg[],\n    sender: SuiAddressArg,\n    recipients: SuiAddressArg[],\n    amounts: SuiTxArg[]\n  ) {\n    // require recipients.length === amounts.length\n    if (recipients.length !== amounts.length) {\n      throw new Error(\n        'transferSuiToMany: recipients.length !== amounts.length'\n      );\n    }\n    const coinObjects = coins.map((coin) => convertObjArg(this.txBlock, coin));\n    const { splitedCoins, mergedCoin } = this.splitMultiCoins(\n      coinObjects,\n      amounts\n    );\n    const recipientObjects = recipients.map((recipient) =>\n      convertAddressArg(this.txBlock, recipient)\n    );\n    recipientObjects.forEach((address, index) => {\n      this.txBlock.transferObjects([splitedCoins[index]], address);\n    });\n    this.txBlock.transferObjects(\n      [mergedCoin],\n      convertAddressArg(this.txBlock, sender)\n    );\n    return this;\n  }\n\n  transferCoin(\n    coins: SuiObjectArg[],\n    sender: SuiAddressArg,\n    recipient: SuiAddressArg,\n    amount: SuiTxArg\n  ) {\n    return this.transferCoinToMany(coins, sender, [recipient], [amount]);\n  }\n\n  stakeSui(amount: SuiTxArg, validatorAddr: SuiAddressArg) {\n    const [stakeCoin] = this.txBlock.splitCoins(\n      this.txBlock.gas,\n      convertArgs(this.txBlock, [amount])\n    );\n    return this.txBlock.moveCall({\n      target: '0x3::sui_system::request_add_stake',\n      arguments: convertArgs(this.txBlock, [\n        SUI_SYSTEM_STATE_OBJECT_ID,\n        stakeCoin,\n        this.txBlock.pure(validatorAddr),\n      ]),\n    });\n  }\n}\n","import {\n  normalizeSuiObjectId,\n  normalizeSuiAddress,\n  isValidSuiObjectId,\n  isValidSuiAddress,\n} from '@mysten/sui.js/utils';\nimport { Inputs } from '@mysten/sui.js/transactions';\nimport { isPureArg } from '@mysten/sui.js/bcs';\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type {\n  TransactionArgument,\n  TransactionBlock,\n  TransactionObjectArgument,\n} from '@mysten/sui.js/transactions';\nimport type {\n  SuiInputTypes,\n  SuiObjectArg,\n  SuiAddressArg,\n  SuiTxArg,\n  SuiVecTxArg,\n} from 'src/types';\n\nexport const getDefaultSuiInputType = (\n  value: SuiTxArg\n): SuiInputTypes | undefined => {\n  if (typeof value === 'string' && isValidSuiObjectId(value)) {\n    return 'object';\n  } else if (typeof value === 'number' || typeof value === 'bigint') {\n    return 'u64';\n  } else if (typeof value === 'boolean') {\n    return 'bool';\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * Since we know the elements in the array are the same type\n * If type is not provided, we will try to infer the type from the first element\n * By default,\n *\n * string is hex and its length equal to 32 =====> object id\n * number, bigint ====> u64\n * boolean =====> bool\n *\n * If type is provided, we will use the type to convert the array\n * @param args\n * @param type 'address' | 'bool' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'signer' | 'object' | string\n */\nexport function makeVecParam(\n  txBlock: TransactionBlock,\n  args: SuiTxArg[],\n  type?: SuiInputTypes\n): TransactionArgument {\n  if (args.length === 0)\n    throw new Error('Transaction builder error: Empty array is not allowed');\n  // Using first element value as default type\n  const defaultSuiType = getDefaultSuiInputType(args[0]);\n  const VECTOR_REGEX = /^vector<(.+)>$/;\n  const STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\n  type = type || defaultSuiType;\n\n  if (type === 'object') {\n    const objects = args.map((arg) =>\n      typeof arg === 'string' && isValidSuiObjectId(arg)\n        ? txBlock.object(normalizeSuiObjectId(arg))\n        : convertObjArg(txBlock, arg as SuiObjectArg)\n    );\n    return txBlock.makeMoveVec({ objects });\n  } else if (\n    typeof type === 'string' &&\n    !VECTOR_REGEX.test(type) &&\n    !STRUCT_REGEX.test(type)\n  ) {\n    return txBlock.pure(args, `vector<${type}>`);\n  } else {\n    const objects = args.map((arg) =>\n      convertObjArg(txBlock, arg as SuiObjectArg)\n    );\n    return txBlock.makeMoveVec({ objects, type });\n  }\n}\n\n/**\n * Check whether it is an valid move vec input.\n *\n * @param arg The argument to check.\n * @returns boolean.\n */\nexport function isMoveVecArg(arg: SuiTxArg | SuiVecTxArg): arg is SuiVecTxArg {\n  if (typeof arg === 'object' && 'vecType' in arg && 'value' in arg) {\n    return true;\n  } else if (Array.isArray(arg)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Convert any valid input into array of TransactionArgument.\n *\n * @param txb The Transaction Block\n * @param args The array of argument to convert.\n * @returns The converted array of TransactionArgument.\n */\nexport function convertArgs(\n  txBlock: TransactionBlock,\n  args: (SuiTxArg | SuiVecTxArg)[]\n) {\n  return args.map((arg) => {\n    if (typeof arg === 'string' && isValidSuiObjectId(arg)) {\n      return txBlock.object(normalizeSuiObjectId(arg));\n    } else if (\n      typeof arg == 'object' &&\n      !isSerializedBcs(arg) &&\n      !isPureArg(arg) &&\n      !isMoveVecArg(arg)\n    ) {\n      return convertObjArg(txBlock, arg as SuiObjectArg);\n    } else if (isMoveVecArg(arg)) {\n      const vecType = 'vecType' in arg;\n      return vecType\n        ? makeVecParam(txBlock, arg.value, arg.vecType)\n        : makeVecParam(txBlock, arg);\n    } else if (isSerializedBcs(arg)) {\n      return arg;\n    } else {\n      return txBlock.pure(arg);\n    }\n  });\n}\n\n/**\n * Convert any valid address input into a TransactionArgument.\n *\n * @param txb The Transaction Block\n * @param arg The address argument to convert.\n * @returns The converted TransactionArgument.\n */\nexport function convertAddressArg(\n  txBlock: TransactionBlock,\n  arg: SuiAddressArg\n) {\n  if (typeof arg === 'string' && isValidSuiAddress(arg)) {\n    return txBlock.pure.address(normalizeSuiAddress(arg));\n  } else if (\n    typeof arg == 'object' &&\n    !isSerializedBcs(arg) &&\n    !isPureArg(arg)\n  ) {\n    return convertObjArg(txBlock, arg as SuiObjectArg);\n  } else if (isPureArg(arg)) {\n    return txBlock.pure(arg);\n  } else {\n    return arg;\n  }\n}\n\n/**\n * Convert any valid object input into a TransactionArgument.\n *\n * @param txb The Transaction Block\n * @param arg The object argument to convert.\n * @returns The converted TransactionArgument.\n */\nexport function convertObjArg(\n  txb: TransactionBlock,\n  arg: SuiObjectArg\n): TransactionObjectArgument {\n  if (typeof arg === 'string') {\n    return txb.object(arg);\n  }\n\n  if ('digest' in arg && 'version' in arg && 'objectId' in arg) {\n    return txb.objectRef(arg);\n  }\n\n  if ('objectId' in arg && 'initialSharedVersion' in arg && 'mutable' in arg) {\n    return txb.sharedObjectRef(arg);\n  }\n\n  if ('Object' in arg) {\n    if ('ImmOrOwned' in arg.Object) {\n      return txb.object(Inputs.ObjectRef(arg.Object.ImmOrOwned));\n    } else if ('Shared' in arg.Object) {\n      return txb.object(Inputs.SharedObjectRef(arg.Object.Shared));\n    } else {\n      throw new Error('Invalid argument type');\n    }\n  }\n\n  if ('kind' in arg) {\n    return arg;\n  }\n\n  throw new Error('Invalid argument type');\n}\n","import { SuiClient } from '@mysten/sui.js/client';\nimport { SuiOwnedObject, SuiSharedObject } from '../suiModel';\nimport { delay } from './util';\nimport type {\n  SuiTransactionBlockResponseOptions,\n  SuiTransactionBlockResponse,\n  SuiObjectDataOptions,\n  SuiObjectData,\n  DryRunTransactionBlockResponse,\n} from '@mysten/sui.js/client';\n\n/**\n * Encapsulates all functions that interact with the sui sdk\n */\nexport class SuiInteractor {\n  public readonly clients: SuiClient[];\n  public currentClient: SuiClient;\n  public readonly fullNodes: string[];\n  public currentFullNode: string;\n\n  constructor(fullNodeUrls: string[]) {\n    if (fullNodeUrls.length === 0)\n      throw new Error('fullNodeUrls must not be empty');\n    this.fullNodes = fullNodeUrls;\n    this.clients = fullNodeUrls.map((url) => new SuiClient({ url }));\n    this.currentFullNode = fullNodeUrls[0];\n    this.currentClient = this.clients[0];\n  }\n\n  switchToNextClient() {\n    const currentClientIdx = this.clients.indexOf(this.currentClient);\n    this.currentClient =\n      this.clients[(currentClientIdx + 1) % this.clients.length];\n    this.currentFullNode =\n      this.fullNodes[(currentClientIdx + 1) % this.clients.length];\n  }\n\n  async sendTx(\n    transactionBlock: Uint8Array | string,\n    signature: string | string[]\n  ): Promise<SuiTransactionBlockResponse> {\n    const txResOptions: SuiTransactionBlockResponseOptions = {\n      showEvents: true,\n      showEffects: true,\n      showObjectChanges: true,\n      showBalanceChanges: true,\n    };\n\n    for (const clientIdx in this.clients) {\n      try {\n        return await this.clients[clientIdx].executeTransactionBlock({\n          transactionBlock,\n          signature,\n          options: txResOptions,\n        });\n      } catch (err) {\n        console.warn(\n          `Failed to send transaction with fullnode ${this.fullNodes[clientIdx]}: ${err}`\n        );\n        await delay(2000);\n      }\n    }\n    throw new Error('Failed to send transaction with all fullnodes');\n  }\n\n  async dryRunTx(\n    transactionBlock: Uint8Array\n  ): Promise<DryRunTransactionBlockResponse> {\n    for (const clientIdx in this.clients) {\n      try {\n        return await this.clients[clientIdx].dryRunTransactionBlock({\n          transactionBlock,\n        });\n      } catch (err) {\n        console.warn(\n          `Failed to dry run transaction with fullnode ${this.fullNodes[clientIdx]}: ${err}`\n        );\n        await delay(2000);\n      }\n    }\n    throw new Error('Failed to dry run transaction with all fullnodes');\n  }\n\n  async getObjects(\n    ids: string[],\n    options?: SuiObjectDataOptions\n  ): Promise<SuiObjectData[]> {\n    const opts: SuiObjectDataOptions = options ?? {\n      showContent: true,\n      showDisplay: true,\n      showType: true,\n      showOwner: true,\n    };\n\n    for (const clientIdx in this.clients) {\n      try {\n        const objects = await this.clients[clientIdx].multiGetObjects({\n          ids,\n          options: opts,\n        });\n        const parsedObjects = objects\n          .map((object) => {\n            return object.data;\n          })\n          .filter((object) => object !== null && object !== undefined);\n        return parsedObjects as SuiObjectData[];\n      } catch (err) {\n        await delay(2000);\n        console.warn(\n          `Failed to get objects with fullnode ${this.fullNodes[clientIdx]}: ${err}`\n        );\n      }\n    }\n    throw new Error('Failed to get objects with all fullnodes');\n  }\n\n  async getObject(id: string, options?: SuiObjectDataOptions) {\n    const objects = await this.getObjects([id], options);\n    return objects[0];\n  }\n\n  /**\n   * @description Update objects in a batch\n   * @param suiObjects\n   */\n  async updateObjects(suiObjects: (SuiOwnedObject | SuiSharedObject)[]) {\n    const objectIds = suiObjects.map((obj) => obj.objectId);\n    const objects = await this.getObjects(objectIds);\n    for (const object of objects) {\n      const suiObject = suiObjects.find(\n        (obj) => obj.objectId === object?.objectId\n      );\n      if (suiObject instanceof SuiSharedObject) {\n        if (\n          object.owner &&\n          typeof object.owner === 'object' &&\n          'Shared' in object.owner\n        ) {\n          suiObject.initialSharedVersion =\n            object.owner.Shared.initial_shared_version;\n        } else {\n          suiObject.initialSharedVersion = undefined;\n        }\n      } else if (suiObject instanceof SuiOwnedObject) {\n        suiObject.version = object?.version;\n        suiObject.digest = object?.digest;\n      }\n    }\n  }\n\n  /**\n   * @description Select coins that add up to the given amount.\n   * @param addr the address of the owner\n   * @param amount the amount that is needed for the coin\n   * @param coinType the coin type, default is '0x2::SUI::SUI'\n   */\n  async selectCoins(\n    addr: string,\n    amount: number,\n    coinType: string = '0x2::SUI::SUI'\n  ) {\n    const selectedCoins: {\n      objectId: string;\n      digest: string;\n      version: string;\n    }[] = [];\n    let totalAmount = 0;\n    let hasNext = true,\n      nextCursor: string | null | undefined = null;\n    while (hasNext && totalAmount < amount) {\n      const coins = await this.currentClient.getCoins({\n        owner: addr,\n        coinType: coinType,\n        cursor: nextCursor,\n      });\n      // Sort the coins by balance in descending order\n      coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));\n      for (const coinData of coins.data) {\n        selectedCoins.push({\n          objectId: coinData.coinObjectId,\n          digest: coinData.digest,\n          version: coinData.version,\n        });\n        totalAmount = totalAmount + parseInt(coinData.balance);\n        if (totalAmount >= amount) {\n          break;\n        }\n      }\n\n      nextCursor = coins.nextCursor;\n      hasNext = coins.hasNextPage;\n    }\n\n    if (!selectedCoins.length) {\n      throw new Error('No valid coins found for the transaction.');\n    }\n    return selectedCoins;\n  }\n}\n","import type { SuiTransactionBlockResponse } from '@mysten/sui.js/client';\nimport type { CallArg } from '@mysten/sui.js/bcs';\n\nexport class SuiOwnedObject {\n  public readonly objectId: string;\n  public version?: string;\n  public digest?: string;\n\n  constructor(param: { objectId: string; version?: string; digest?: string }) {\n    this.objectId = param.objectId;\n    this.version = param.version;\n    this.digest = param.digest;\n  }\n\n  /**\n   * Check if the object is fully initialized.\n   * So that when it's used as an input, it won't be necessary to fetch from fullnode again.\n   * Which can save time when sending transactions.\n   */\n  isFullObject(): boolean {\n    return !!this.version && !!this.digest;\n  }\n\n  asCallArg(): CallArg | string {\n    if (!this.version || !this.digest) {\n      return this.objectId;\n    }\n    return {\n      Object: {\n        ImmOrOwned: {\n          objectId: this.objectId,\n          version: this.version,\n          digest: this.digest,\n        },\n      },\n    };\n  }\n\n  /**\n   * Update object version & digest based on the transaction response.\n   * @param txResponse\n   */\n  updateFromTxResponse(txResponse: SuiTransactionBlockResponse) {\n    const changes = txResponse.objectChanges;\n    if (!changes) {\n      throw new Error('Bad transaction response!');\n    }\n    for (const change of changes) {\n      if (change.type === 'mutated' && change.objectId === this.objectId) {\n        this.digest = change.digest;\n        this.version = change.version;\n        return;\n      }\n    }\n    throw new Error('Could not find object in transaction response!');\n  }\n}\n","import type { CallArg } from '@mysten/sui.js/bcs';\n\nexport class SuiSharedObject {\n  public readonly objectId: string;\n  public initialSharedVersion?: string;\n\n  constructor(param: {\n    objectId: string;\n    initialSharedVersion?: string;\n    mutable?: boolean;\n  }) {\n    this.objectId = param.objectId;\n    this.initialSharedVersion = param.initialSharedVersion;\n  }\n\n  asCallArg(mutable: boolean = false): CallArg | string {\n    if (!this.initialSharedVersion) {\n      return this.objectId;\n    }\n    return {\n      Object: {\n        Shared: {\n          objectId: this.objectId,\n          initialSharedVersion: this.initialSharedVersion,\n          mutable,\n        },\n      },\n    };\n  }\n}\n","export const delay = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { MultiSigPublicKey } from '@mysten/sui.js/multisig';\nimport type { PublicKey } from '@mysten/sui.js/src/cryptography';\nimport { ed25519PublicKeyFromBase64 } from './publickey';\n\nexport type PublicKeyWeightPair = {\n  publicKey: PublicKey;\n  weight: number;\n};\n\nexport class MultiSigClient {\n  public readonly pksWeightPairs: PublicKeyWeightPair[];\n  public readonly threshold: number;\n  public readonly multiSigPublicKey: MultiSigPublicKey;\n  constructor(pks: PublicKeyWeightPair[], threshold: number) {\n    this.pksWeightPairs = pks;\n    this.threshold = threshold;\n    this.multiSigPublicKey = MultiSigPublicKey.fromPublicKeys({\n      threshold: this.threshold,\n      publicKeys: this.pksWeightPairs,\n    });\n  }\n\n  static fromRawEd25519PublicKeys(\n    rawPublicKeys: string[],\n    weights: number[],\n    threshold: number\n  ): MultiSigClient {\n    const pks = rawPublicKeys.map((rawPublicKey, i) => {\n      return {\n        publicKey: ed25519PublicKeyFromBase64(rawPublicKey),\n        weight: weights[i],\n      };\n    });\n    return new MultiSigClient(pks, threshold);\n  }\n\n  multiSigAddress(): string {\n    return this.multiSigPublicKey.toSuiAddress();\n  }\n\n  combinePartialSigs(sigs: string[]): string {\n    return this.multiSigPublicKey.combinePartialSignatures(sigs);\n  }\n}\n","import { PublicKey } from '@mysten/sui.js/cryptography';\nimport { Ed25519PublicKey } from '@mysten/sui.js/keypairs/ed25519';\nimport { fromB64 } from '@mysten/sui.js/utils';\n\nexport function ed25519PublicKeyFromBase64(rawPubkey: string): PublicKey {\n  let bytes = fromB64(rawPubkey);\n  // rawPubkeys should either be 32 bytes or 33 bytes (with the first byte being flag)\n  if (bytes.length !== 32 && bytes.length !== 33) throw 'invalid pubkey length';\n  bytes = bytes.length === 33 ? bytes.slice(1) : bytes;\n  return new Ed25519PublicKey(bytes);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAc,iCAAd;AACA,wBAAc,wCADd;;;ACGA,IAAAA,iBAA+B;AAC/B,IAAAC,uBAAiC;;;ACJjC,IAAAC,kBAA+B;;;ACA/B,qBAA+B;AAOxB,IAAM,sBAAsB,CACjC,mBAAqC,CAAC,MACnC;AACH,QAAM;AAAA,IACJ,eAAe;AAAA,IACf,aAAa;AAAA,IACb,eAAe;AAAA,EACjB,IAAI;AACJ,SAAO,cAAc,YAAY,KAAK,aAAa,IAAI,CAAC,KAAK,YAAY;AAC3E;AAeO,IAAM,aAAa,CACxB,WACA,mBAAqC,CAAC,MACnC;AACH,QAAM,aAAa,oBAAoB,gBAAgB;AACvD,SAAO,8BAAe,cAAc,WAAW,UAAU;AAC3D;;;ACrCA,mBAAwB;AAMjB,IAAM,QAAQ,CAAC,QACpB,kCAAkC,KAAK,GAAG;AAOrC,IAAM,WAAW,CAAC,QAAgB,0BAA0B,KAAK,GAAG;AAMpE,IAAM,UAAU,CAAC,WAA+B;AACrD,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI,MAAM,yCAAyC;AAAA,EAC3D;AACA,QAAM,SAAS,OACZ,QAAQ,MAAM,EAAE,EAChB,MAAM,SAAS,GACd,IAAI,CAAC,SAAS,SAAS,MAAM,EAAE,CAAC;AAEpC,MAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAClC,UAAM,IAAI,MAAM,wBAAwB,MAAM,EAAE;AAAA,EAClD;AACA,SAAO,WAAW,KAAK,MAAM;AAC/B;AAKO,IAAM,0BAA0B,CAAC,QAA4B;AAClE,MAAI,MAAM,GAAG,GAAG;AACd,WAAO,QAAQ,GAAG;AAAA,EACpB,WAAW,SAAS,GAAG,GAAG;AACxB,eAAO,sBAAQ,GAAG;AAAA,EACpB,OAAO;AACL,UAAM,IAAI,MAAM,iDAAiD;AAAA,EACnE;AACF;AAEA,IAAM,mBAAmB;AACzB,IAAM,0BAA0B;AASzB,IAAM,sBAAsB,CAAC,QAAgC;AAClE,MAAI,IAAI,WAAW,yBAAyB;AAE1C,UAAM,IAAI,MAAM,GAAG,gBAAgB;AAAA,EACrC,WAAW,IAAI,WAAW,mBAAmB,KAAK,IAAI,CAAC,MAAM,GAAG;AAE9D,WAAO,IAAI,MAAM,CAAC;AAAA,EACpB,WAAW,IAAI,WAAW,kBAAkB;AAC1C,WAAO;AAAA,EACT;AACA,QAAM,IAAI,MAAM,oBAAoB;AACtC;;;ACrEA,mBAAgD;AAChD,qBAAyB;AAElB,IAAM,mBAAmB,CAAC,gBAAyB,OAAO;AAC/D,QAAM,WAAW,kBAAkB,KAAK,MAAM;AAC9C,aAAO,aAAAC,kBAAY,yBAAU,QAAQ;AACvC;;;AHDA,0BAGO;AAEA,IAAM,oBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAe7B,YAAY,EAAE,WAAW,UAAU,IAAyB,CAAC,GAAG;AAG9D,SAAK,YAAY,aAAa;AAC9B,SAAK,YAAY,aAAa;AAC9B,QAAI,CAAC,KAAK,aAAa,CAAC,KAAK,WAAW;AACtC,WAAK,YAAY,iBAAiB,EAAE;AAAA,IACtC;AAGA,SAAK,iBAAiB,KAAK,YACvB,KAAK,eAAe,KAAK,SAAS,IAClC,WAAW,KAAK,SAAS;AAC7B,SAAK,iBAAiB,KAAK,eAAe,aAAa,EAAE,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,WAAmB;AAChC,QAAI,UAAU,WAAW,0CAAsB,GAAG;AAChD,YAAM,EAAE,WAAW,oBAAoB,QAAI,yCAAoB,SAAS;AACxE,aAAO,+BAAe;AAAA,QACpB,oBAAoB,mBAAmB;AAAA,MACzC;AAAA,IACF;AAEA,WAAO,+BAAe;AAAA,MACpB,oBAAoB,wBAAwB,SAAS,CAAC;AAAA,IACxD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,kBAAqC;AAC9C,QAAI,CAAC,oBAAoB,CAAC,KAAK;AAAW,aAAO,KAAK;AACtD,WAAO,WAAW,KAAK,WAAW,gBAAgB;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,kBAAqC;AAC9C,QAAI,CAAC,oBAAoB,CAAC,KAAK;AAAW,aAAO,KAAK;AACtD,WAAO,WAAW,KAAK,WAAW,gBAAgB,EAC/C,aAAa,EACb,aAAa;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,kBAAoC;AAChD,QAAI,KAAK,WAAW;AAClB,WAAK,iBAAiB,WAAW,KAAK,WAAW,gBAAgB;AACjE,WAAK,iBAAiB,KAAK,eAAe,aAAa,EAAE,aAAa;AAAA,IACxE;AAAA,EACF;AACF;;;AIzFA,IAAAC,uBAAiC;AACjC,IAAAC,gBAA2C;;;ACD3C,IAAAC,gBAKO;AACP,0BAAuB;AACvB,iBAA0B;AAC1B,IAAAC,cAAgC;AAczB,IAAM,yBAAyB,CACpC,UAC8B;AAC9B,MAAI,OAAO,UAAU,gBAAY,kCAAmB,KAAK,GAAG;AAC1D,WAAO;AAAA,EACT,WAAW,OAAO,UAAU,YAAY,OAAO,UAAU,UAAU;AACjE,WAAO;AAAA,EACT,WAAW,OAAO,UAAU,WAAW;AACrC,WAAO;AAAA,EACT,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAeO,SAAS,aACd,SACA,MACA,MACqB;AACrB,MAAI,KAAK,WAAW;AAClB,UAAM,IAAI,MAAM,uDAAuD;AAEzE,QAAM,iBAAiB,uBAAuB,KAAK,CAAC,CAAC;AACrD,QAAM,eAAe;AACrB,QAAM,eAAe;AAErB,SAAO,QAAQ;AAEf,MAAI,SAAS,UAAU;AACrB,UAAM,UAAU,KAAK;AAAA,MAAI,CAAC,QACxB,OAAO,QAAQ,gBAAY,kCAAmB,GAAG,IAC7C,QAAQ,WAAO,oCAAqB,GAAG,CAAC,IACxC,cAAc,SAAS,GAAmB;AAAA,IAChD;AACA,WAAO,QAAQ,YAAY,EAAE,QAAQ,CAAC;AAAA,EACxC,WACE,OAAO,SAAS,YAChB,CAAC,aAAa,KAAK,IAAI,KACvB,CAAC,aAAa,KAAK,IAAI,GACvB;AACA,WAAO,QAAQ,KAAK,MAAM,UAAU,IAAI,GAAG;AAAA,EAC7C,OAAO;AACL,UAAM,UAAU,KAAK;AAAA,MAAI,CAAC,QACxB,cAAc,SAAS,GAAmB;AAAA,IAC5C;AACA,WAAO,QAAQ,YAAY,EAAE,SAAS,KAAK,CAAC;AAAA,EAC9C;AACF;AAQO,SAAS,aAAa,KAAiD;AAC5E,MAAI,OAAO,QAAQ,YAAY,aAAa,OAAO,WAAW,KAAK;AACjE,WAAO;AAAA,EACT,WAAW,MAAM,QAAQ,GAAG,GAAG;AAC7B,WAAO;AAAA,EACT;AACA,SAAO;AACT;AASO,SAAS,YACd,SACA,MACA;AACA,SAAO,KAAK,IAAI,CAAC,QAAQ;AACvB,QAAI,OAAO,QAAQ,gBAAY,kCAAmB,GAAG,GAAG;AACtD,aAAO,QAAQ,WAAO,oCAAqB,GAAG,CAAC;AAAA,IACjD,WACE,OAAO,OAAO,YACd,KAAC,6BAAgB,GAAG,KACpB,KAAC,sBAAU,GAAG,KACd,CAAC,aAAa,GAAG,GACjB;AACA,aAAO,cAAc,SAAS,GAAmB;AAAA,IACnD,WAAW,aAAa,GAAG,GAAG;AAC5B,YAAM,UAAU,aAAa;AAC7B,aAAO,UACH,aAAa,SAAS,IAAI,OAAO,IAAI,OAAO,IAC5C,aAAa,SAAS,GAAG;AAAA,IAC/B,eAAW,6BAAgB,GAAG,GAAG;AAC/B,aAAO;AAAA,IACT,OAAO;AACL,aAAO,QAAQ,KAAK,GAAG;AAAA,IACzB;AAAA,EACF,CAAC;AACH;AASO,SAAS,kBACd,SACA,KACA;AACA,MAAI,OAAO,QAAQ,gBAAY,iCAAkB,GAAG,GAAG;AACrD,WAAO,QAAQ,KAAK,YAAQ,mCAAoB,GAAG,CAAC;AAAA,EACtD,WACE,OAAO,OAAO,YACd,KAAC,6BAAgB,GAAG,KACpB,KAAC,sBAAU,GAAG,GACd;AACA,WAAO,cAAc,SAAS,GAAmB;AAAA,EACnD,eAAW,sBAAU,GAAG,GAAG;AACzB,WAAO,QAAQ,KAAK,GAAG;AAAA,EACzB,OAAO;AACL,WAAO;AAAA,EACT;AACF;AASO,SAAS,cACd,KACA,KAC2B;AAC3B,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAO,IAAI,OAAO,GAAG;AAAA,EACvB;AAEA,MAAI,YAAY,OAAO,aAAa,OAAO,cAAc,KAAK;AAC5D,WAAO,IAAI,UAAU,GAAG;AAAA,EAC1B;AAEA,MAAI,cAAc,OAAO,0BAA0B,OAAO,aAAa,KAAK;AAC1E,WAAO,IAAI,gBAAgB,GAAG;AAAA,EAChC;AAEA,MAAI,YAAY,KAAK;AACnB,QAAI,gBAAgB,IAAI,QAAQ;AAC9B,aAAO,IAAI,OAAO,2BAAO,UAAU,IAAI,OAAO,UAAU,CAAC;AAAA,IAC3D,WAAW,YAAY,IAAI,QAAQ;AACjC,aAAO,IAAI,OAAO,2BAAO,gBAAgB,IAAI,OAAO,MAAM,CAAC;AAAA,IAC7D,OAAO;AACL,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACzC;AAAA,EACF;AAEA,MAAI,UAAU,KAAK;AACjB,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,MAAM,uBAAuB;AACzC;;;ADlLO,IAAM,aAAN,MAAiB;AAAA,EAGtB,YAAY,aAAgC;AAC1C,SAAK,UAAU,IAAI,sCAAiB,WAAW;AAAA,EACjD;AAAA;AAAA,EAGA,IAAI,MAAM;AACR,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EACA,IAAI,YAAY;AACd,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEA,QAAQ,OAAe;AACrB,WAAO,KAAK,QAAQ,KAAK,OAAO,SAAS;AAAA,EAC3C;AAAA,EACA,KAAK,OAAgB,MAAe;AAClC,WAAO,KAAK,QAAQ,KAAK,OAAO,IAAI;AAAA,EACtC;AAAA,EACA,OAAO,OAA+B;AACpC,WAAO,KAAK,QAAQ,OAAO,KAAK;AAAA,EAClC;AAAA,EACA,UAAU,KAAmB;AAC3B,WAAO,KAAK,QAAQ,UAAU,GAAG;AAAA,EACnC;AAAA,EACA,gBAAgB,KAAsB;AACpC,WAAO,KAAK,QAAQ,gBAAgB,GAAG;AAAA,EACzC;AAAA,EACA,UAAU,QAAgB;AACxB,WAAO,KAAK,QAAQ,UAAU,MAAM;AAAA,EACtC;AAAA,EACA,kBAAkB,QAAgB;AAChC,WAAO,KAAK,QAAQ,kBAAkB,MAAM;AAAA,EAC9C;AAAA,EACA,cAAc,YAAoC;AAChD,WAAO,KAAK,QAAQ,cAAc,UAAU;AAAA,EAC9C;AAAA,EACA,YAAY,OAAwB;AAClC,WAAO,KAAK,QAAQ,YAAY,KAAK;AAAA,EACvC;AAAA,EACA,aAAa,QAAyB;AACpC,WAAO,KAAK,QAAQ,aAAa,MAAM;AAAA,EACzC;AAAA,EACA,YAAY,OAAe;AACzB,WAAO,KAAK,QAAQ,YAAY,KAAK;AAAA,EACvC;AAAA,EACA,cAAc,UAA0B;AACtC,WAAO,KAAK,QAAQ,cAAc,QAAQ;AAAA,EAC5C;AAAA,EACA,YAAY;AACV,WAAO,KAAK,QAAQ,UAAU;AAAA,EAChC;AAAA,EACA,KAAK,QAIF;AACD,WAAO,KAAK,QAAQ,KAAK,MAAM;AAAA,EACjC;AAAA,EACA,MACE,SAGI,CAAC,GACL;AACA,WAAO,KAAK,QAAQ,MAAM,MAAM;AAAA,EAClC;AAAA,EACA,UAAU,SAAiC,CAAC,GAAG;AAC7C,WAAO,KAAK,QAAQ,UAAU,MAAM;AAAA,EACtC;AAAA,EACA,OAAO,MAAuB;AAC5B,WAAO,KAAK,QAAQ,IAAI,GAAG,IAAI;AAAA,EACjC;AAAA,EACA,QAAQ;AAAA,IACN;AAAA,IACA;AAAA,EACF,GAGG;AACD,WAAO,KAAK,QAAQ,QAAQ,EAAE,SAAS,aAAa,CAAC;AAAA,EACvD;AAAA,EACA,QAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKG;AACD,WAAO,KAAK,QAAQ,QAAQ,EAAE,SAAS,cAAc,WAAW,OAAO,CAAC;AAAA,EAC1E;AAAA,EACA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,EACF,GAGG;AACD,WAAO,KAAK,QAAQ,YAAY,EAAE,SAAS,KAAK,CAAC;AAAA,EACnD;AAAA;AAAA,EAIA,gBAAgB,SAAyB,SAAwB;AAC/D,WAAO,KAAK,QAAQ;AAAA,MAClB,QAAQ,IAAI,CAAC,WAAW,cAAc,KAAK,SAAS,MAAM,CAAC;AAAA,MAC3D,kBAAkB,KAAK,SAAS,OAAO;AAAA,IACzC;AAAA,EACF;AAAA,EAEA,WAAW,MAAoB,SAAqB;AAClD,UAAM,MAAM,KAAK,QAAQ;AAAA,MACvB,cAAc,KAAK,SAAS,IAAI;AAAA,MAChC,YAAY,KAAK,SAAS,OAAO;AAAA,IACnC;AACA,WAAO,QAAQ,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC,CAAC;AAAA,EACrC;AAAA,EAEA,WAAW,aAA2B,SAAyB;AAC7D,UAAM,oBAAoB,cAAc,KAAK,SAAS,WAAW;AACjE,UAAM,gBAAgB,QAAQ;AAAA,MAAI,CAAC,WACjC,cAAc,KAAK,SAAS,MAAM;AAAA,IACpC;AACA,WAAO,KAAK,QAAQ,WAAW,mBAAmB,aAAa;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,SACE,QACA,OAAmC,CAAC,GACpC,WAAqB,CAAC,GACtB;AAEA,UAAM,QACJ;AACF,UAAM,QAAQ,OAAO,MAAM,KAAK;AAChC,QAAI,UAAU;AACZ,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AACF,UAAM,gBAAgB,YAAY,KAAK,SAAS,IAAI;AACpD,WAAO,KAAK,QAAQ,SAAS;AAAA,MAC3B;AAAA,MACA,WAAW;AAAA,MACX,eAAe;AAAA,IACjB,CAAC;AAAA,EACH;AAAA;AAAA,EAIA,kBAAkB,YAA6B,SAAqB;AAElE,QAAI,WAAW,WAAW,QAAQ,QAAQ;AACxC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,UAAM,QAAQ,KAAK,QAAQ;AAAA,MACzB,KAAK,QAAQ;AAAA,MACb,YAAY,KAAK,SAAS,OAAO;AAAA,IACnC;AACA,UAAM,mBAAmB,WAAW;AAAA,MAAI,CAAC,cACvC,kBAAkB,KAAK,SAAS,SAAS;AAAA,IAC3C;AACA,qBAAiB,QAAQ,CAAC,SAAS,UAAU;AAC3C,WAAK,QAAQ,gBAAgB,CAAC,MAAM,KAAK,CAAC,GAAG,OAAO;AAAA,IACtD,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,SAAwB,QAAkB;AACpD,WAAO,KAAK,kBAAkB,CAAC,OAAO,GAAG,CAAC,MAAM,CAAC;AAAA,EACnD;AAAA,EAEA,oBAAoB,OAAuB,QAAkB;AAC3D,UAAM,cAAc,MAAM,IAAI,CAAC,SAAS,cAAc,KAAK,SAAS,IAAI,CAAC;AACzE,UAAM,aAAa,YAAY,CAAC;AAChC,QAAI,MAAM,SAAS,GAAG;AACpB,WAAK,QAAQ,WAAW,YAAY,YAAY,MAAM,CAAC,CAAC;AAAA,IAC1D;AACA,UAAM,CAAC,QAAQ,IAAI,KAAK,QAAQ;AAAA,MAC9B;AAAA,MACA,YAAY,KAAK,SAAS,CAAC,MAAM,CAAC;AAAA,IACpC;AACA,WAAO,CAAC,UAAU,UAAU;AAAA,EAC9B;AAAA,EAEA,gBAAgB,SAAqB;AACnC,WAAO,KAAK,QAAQ;AAAA,MAClB,KAAK,QAAQ;AAAA,MACb,YAAY,KAAK,SAAS,OAAO;AAAA,IACnC;AAAA,EACF;AAAA,EAEA,gBAAgB,OAAuB,SAAqB;AAC1D,UAAM,cAAc,MAAM,IAAI,CAAC,SAAS,cAAc,KAAK,SAAS,IAAI,CAAC;AACzE,UAAM,aAAa,YAAY,CAAC;AAChC,QAAI,MAAM,SAAS,GAAG;AACpB,WAAK,QAAQ,WAAW,YAAY,YAAY,MAAM,CAAC,CAAC;AAAA,IAC1D;AACA,UAAM,eAAe,KAAK,QAAQ;AAAA,MAChC;AAAA,MACA,YAAY,KAAK,SAAS,OAAO;AAAA,IACnC;AACA,WAAO,EAAE,cAAc,WAAW;AAAA,EACpC;AAAA,EAEA,mBACE,OACA,QACA,YACA,SACA;AAEA,QAAI,WAAW,WAAW,QAAQ,QAAQ;AACxC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,UAAM,cAAc,MAAM,IAAI,CAAC,SAAS,cAAc,KAAK,SAAS,IAAI,CAAC;AACzE,UAAM,EAAE,cAAc,WAAW,IAAI,KAAK;AAAA,MACxC;AAAA,MACA;AAAA,IACF;AACA,UAAM,mBAAmB,WAAW;AAAA,MAAI,CAAC,cACvC,kBAAkB,KAAK,SAAS,SAAS;AAAA,IAC3C;AACA,qBAAiB,QAAQ,CAAC,SAAS,UAAU;AAC3C,WAAK,QAAQ,gBAAgB,CAAC,aAAa,KAAK,CAAC,GAAG,OAAO;AAAA,IAC7D,CAAC;AACD,SAAK,QAAQ;AAAA,MACX,CAAC,UAAU;AAAA,MACX,kBAAkB,KAAK,SAAS,MAAM;AAAA,IACxC;AACA,WAAO;AAAA,EACT;AAAA,EAEA,aACE,OACA,QACA,WACA,QACA;AACA,WAAO,KAAK,mBAAmB,OAAO,QAAQ,CAAC,SAAS,GAAG,CAAC,MAAM,CAAC;AAAA,EACrE;AAAA,EAEA,SAAS,QAAkB,eAA8B;AACvD,UAAM,CAAC,SAAS,IAAI,KAAK,QAAQ;AAAA,MAC/B,KAAK,QAAQ;AAAA,MACb,YAAY,KAAK,SAAS,CAAC,MAAM,CAAC;AAAA,IACpC;AACA,WAAO,KAAK,QAAQ,SAAS;AAAA,MAC3B,QAAQ;AAAA,MACR,WAAW,YAAY,KAAK,SAAS;AAAA,QACnC;AAAA,QACA;AAAA,QACA,KAAK,QAAQ,KAAK,aAAa;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;;;AElSA,oBAA0B;;;ACGnB,IAAM,iBAAN,MAAqB;AAAA,EAK1B,YAAY,OAAgE;AAC1E,SAAK,WAAW,MAAM;AACtB,SAAK,UAAU,MAAM;AACrB,SAAK,SAAS,MAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAwB;AACtB,WAAO,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,KAAK;AAAA,EAClC;AAAA,EAEA,YAA8B;AAC5B,QAAI,CAAC,KAAK,WAAW,CAAC,KAAK,QAAQ;AACjC,aAAO,KAAK;AAAA,IACd;AACA,WAAO;AAAA,MACL,QAAQ;AAAA,QACN,YAAY;AAAA,UACV,UAAU,KAAK;AAAA,UACf,SAAS,KAAK;AAAA,UACd,QAAQ,KAAK;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,qBAAqB,YAAyC;AAC5D,UAAM,UAAU,WAAW;AAC3B,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,eAAW,UAAU,SAAS;AAC5B,UAAI,OAAO,SAAS,aAAa,OAAO,aAAa,KAAK,UAAU;AAClE,aAAK,SAAS,OAAO;AACrB,aAAK,UAAU,OAAO;AACtB;AAAA,MACF;AAAA,IACF;AACA,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AACF;;;ACtDO,IAAM,kBAAN,MAAsB;AAAA,EAI3B,YAAY,OAIT;AACD,SAAK,WAAW,MAAM;AACtB,SAAK,uBAAuB,MAAM;AAAA,EACpC;AAAA,EAEA,UAAU,UAAmB,OAAyB;AACpD,QAAI,CAAC,KAAK,sBAAsB;AAC9B,aAAO,KAAK;AAAA,IACd;AACA,WAAO;AAAA,MACL,QAAQ;AAAA,QACN,QAAQ;AAAA,UACN,UAAU,KAAK;AAAA,UACf,sBAAsB,KAAK;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AC7BO,IAAM,QAAQ,CAAC,OACpB,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;;;AHa3C,IAAM,gBAAN,MAAoB;AAAA,EAMzB,YAAY,cAAwB;AAClC,QAAI,aAAa,WAAW;AAC1B,YAAM,IAAI,MAAM,gCAAgC;AAClD,SAAK,YAAY;AACjB,SAAK,UAAU,aAAa,IAAI,CAAC,QAAQ,IAAI,wBAAU,EAAE,IAAI,CAAC,CAAC;AAC/D,SAAK,kBAAkB,aAAa,CAAC;AACrC,SAAK,gBAAgB,KAAK,QAAQ,CAAC;AAAA,EACrC;AAAA,EAEA,qBAAqB;AACnB,UAAM,mBAAmB,KAAK,QAAQ,QAAQ,KAAK,aAAa;AAChE,SAAK,gBACH,KAAK,SAAS,mBAAmB,KAAK,KAAK,QAAQ,MAAM;AAC3D,SAAK,kBACH,KAAK,WAAW,mBAAmB,KAAK,KAAK,QAAQ,MAAM;AAAA,EAC/D;AAAA,EAEA,MAAM,OACJ,kBACA,WACsC;AACtC,UAAM,eAAmD;AAAA,MACvD,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,mBAAmB;AAAA,MACnB,oBAAoB;AAAA,IACtB;AAEA,eAAW,aAAa,KAAK,SAAS;AACpC,UAAI;AACF,eAAO,MAAM,KAAK,QAAQ,SAAS,EAAE,wBAAwB;AAAA,UAC3D;AAAA,UACA;AAAA,UACA,SAAS;AAAA,QACX,CAAC;AAAA,MACH,SAAS,KAAK;AACZ,gBAAQ;AAAA,UACN,4CAA4C,KAAK,UAAU,SAAS,CAAC,KAAK,GAAG;AAAA,QAC/E;AACA,cAAM,MAAM,GAAI;AAAA,MAClB;AAAA,IACF;AACA,UAAM,IAAI,MAAM,+CAA+C;AAAA,EACjE;AAAA,EAEA,MAAM,SACJ,kBACyC;AACzC,eAAW,aAAa,KAAK,SAAS;AACpC,UAAI;AACF,eAAO,MAAM,KAAK,QAAQ,SAAS,EAAE,uBAAuB;AAAA,UAC1D;AAAA,QACF,CAAC;AAAA,MACH,SAAS,KAAK;AACZ,gBAAQ;AAAA,UACN,+CAA+C,KAAK,UAAU,SAAS,CAAC,KAAK,GAAG;AAAA,QAClF;AACA,cAAM,MAAM,GAAI;AAAA,MAClB;AAAA,IACF;AACA,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACpE;AAAA,EAEA,MAAM,WACJ,KACA,SAC0B;AAC1B,UAAM,OAA6B,WAAW;AAAA,MAC5C,aAAa;AAAA,MACb,aAAa;AAAA,MACb,UAAU;AAAA,MACV,WAAW;AAAA,IACb;AAEA,eAAW,aAAa,KAAK,SAAS;AACpC,UAAI;AACF,cAAM,UAAU,MAAM,KAAK,QAAQ,SAAS,EAAE,gBAAgB;AAAA,UAC5D;AAAA,UACA,SAAS;AAAA,QACX,CAAC;AACD,cAAM,gBAAgB,QACnB,IAAI,CAAC,WAAW;AACf,iBAAO,OAAO;AAAA,QAChB,CAAC,EACA,OAAO,CAAC,WAAW,WAAW,QAAQ,WAAW,MAAS;AAC7D,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,cAAM,MAAM,GAAI;AAChB,gBAAQ;AAAA,UACN,uCAAuC,KAAK,UAAU,SAAS,CAAC,KAAK,GAAG;AAAA,QAC1E;AAAA,MACF;AAAA,IACF;AACA,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC5D;AAAA,EAEA,MAAM,UAAU,IAAY,SAAgC;AAC1D,UAAM,UAAU,MAAM,KAAK,WAAW,CAAC,EAAE,GAAG,OAAO;AACnD,WAAO,QAAQ,CAAC;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,cAAc,YAAkD;AACpE,UAAM,YAAY,WAAW,IAAI,CAAC,QAAQ,IAAI,QAAQ;AACtD,UAAM,UAAU,MAAM,KAAK,WAAW,SAAS;AAC/C,eAAW,UAAU,SAAS;AAC5B,YAAM,YAAY,WAAW;AAAA,QAC3B,CAAC,QAAQ,IAAI,aAAa,QAAQ;AAAA,MACpC;AACA,UAAI,qBAAqB,iBAAiB;AACxC,YACE,OAAO,SACP,OAAO,OAAO,UAAU,YACxB,YAAY,OAAO,OACnB;AACA,oBAAU,uBACR,OAAO,MAAM,OAAO;AAAA,QACxB,OAAO;AACL,oBAAU,uBAAuB;AAAA,QACnC;AAAA,MACF,WAAW,qBAAqB,gBAAgB;AAC9C,kBAAU,UAAU,QAAQ;AAC5B,kBAAU,SAAS,QAAQ;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,YACJ,MACA,QACA,WAAmB,iBACnB;AACA,UAAM,gBAIA,CAAC;AACP,QAAI,cAAc;AAClB,QAAI,UAAU,MACZ,aAAwC;AAC1C,WAAO,WAAW,cAAc,QAAQ;AACtC,YAAM,QAAQ,MAAM,KAAK,cAAc,SAAS;AAAA,QAC9C,OAAO;AAAA,QACP;AAAA,QACA,QAAQ;AAAA,MACV,CAAC;AAED,YAAM,KAAK,KAAK,CAAC,GAAG,MAAM,SAAS,EAAE,OAAO,IAAI,SAAS,EAAE,OAAO,CAAC;AACnE,iBAAW,YAAY,MAAM,MAAM;AACjC,sBAAc,KAAK;AAAA,UACjB,UAAU,SAAS;AAAA,UACnB,QAAQ,SAAS;AAAA,UACjB,SAAS,SAAS;AAAA,QACpB,CAAC;AACD,sBAAc,cAAc,SAAS,SAAS,OAAO;AACrD,YAAI,eAAe,QAAQ;AACzB;AAAA,QACF;AAAA,MACF;AAEA,mBAAa,MAAM;AACnB,gBAAU,MAAM;AAAA,IAClB;AAEA,QAAI,CAAC,cAAc,QAAQ;AACzB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,WAAO;AAAA,EACT;AACF;;;AP5KO,IAAM,SAAN,MAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAelB,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAkB,CAAC,GAAG;AAEpB,SAAK,iBAAiB,IAAI,kBAAkB,EAAE,WAAW,UAAU,CAAC;AAEpE,mBAAe,gBAAgB,KAAC,+BAAe,eAAe,SAAS,CAAC;AACxE,SAAK,gBAAgB,IAAI,cAAc,YAAY;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,kBAAqC;AAC9C,WAAO,KAAK,eAAe,WAAW,gBAAgB;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,kBAAoC;AAChD,SAAK,eAAe,cAAc,gBAAgB;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,kBAAqC;AAC9C,WAAO,KAAK,eAAe,WAAW,gBAAgB;AAAA,EACxD;AAAA,EAEA,iBAAiB;AACf,WAAO,KAAK,eAAe;AAAA,EAC7B;AAAA,EAEA,MAAM,WAAW,UAAmB,kBAAqC;AACvE,UAAM,QAAQ,KAAK,eAAe,WAAW,gBAAgB;AAC7D,WAAO,KAAK,cAAc,cAAc,WAAW,EAAE,OAAO,SAAS,CAAC;AAAA,EACxE;AAAA,EAEA,SAAS;AACP,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EAEA,MAAM,WAAW,WAAqB,SAAgC;AACpE,WAAO,KAAK,cAAc,WAAW,WAAW,OAAO;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,cAAc,YAAkD;AACpE,WAAO,KAAK,cAAc,cAAc,UAAU;AAAA,EACpD;AAAA,EAEA,MAAM,QACJ,IACA,kBACA;AACA,QAAI,cAAc,YAAY;AAC5B,SAAG,UAAU,KAAK,WAAW,gBAAgB,CAAC;AAAA,IAChD;AACA,UAAM,UAAU,cAAc,aAAa,GAAG,UAAU;AACxD,UAAM,UACJ,mBAAmB,wCACf,MAAM,QAAQ,MAAM,EAAE,QAAQ,KAAK,OAAO,EAAE,CAAC,IAC7C;AACN,UAAM,UAAU,KAAK,WAAW,gBAAgB;AAChD,WAAO,MAAM,QAAQ,qBAAqB,OAAO;AAAA,EACnD;AAAA,EAEA,MAAM,eACJ,IACA,kBACsC;AACtC,UAAM,EAAE,OAAO,UAAU,IAAI,MAAM,KAAK,QAAQ,IAAI,gBAAgB;AACpE,WAAO,KAAK,cAAc,OAAO,OAAO,SAAS;AAAA,EACnD;AAAA,EAEA,MAAM,UACJ,IACA,kBACyC;AACzC,QAAI,cAAc,YAAY;AAC5B,SAAG,UAAU,KAAK,WAAW,gBAAgB,CAAC;AAAA,IAChD;AACA,UAAM,UAAU,cAAc,aAAa,GAAG,UAAU;AACxD,UAAM,UACJ,mBAAmB,wCACf,MAAM,QAAQ,MAAM,EAAE,QAAQ,KAAK,OAAO,EAAE,CAAC,IAC7C;AACN,WAAO,KAAK,cAAc,SAAS,OAAO;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,YACJ,WACA,QACA,kBACA;AACA,UAAM,KAAK,IAAI,WAAW;AAC1B,OAAG,YAAY,WAAW,MAAM;AAChC,WAAO,KAAK,eAAe,IAAI,gBAAgB;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,kBACJ,YACA,SACA,kBACA;AACA,UAAM,KAAK,IAAI,WAAW;AAC1B,OAAG,kBAAkB,YAAY,OAAO;AACxC,WAAO,KAAK,eAAe,IAAI,gBAAgB;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,mBACJ,YACA,SACA,UACA,kBACA;AACA,UAAM,KAAK,IAAI,WAAW;AAC1B,UAAM,QAAQ,KAAK,eAAe,WAAW,gBAAgB;AAC7D,UAAM,cAAc,QAAQ,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AACrD,UAAM,QAAQ,MAAM,KAAK,cAAc;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,OAAG;AAAA,MACD,MAAM,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,MAC3B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,KAAK,eAAe,IAAI,gBAAgB;AAAA,EACjD;AAAA,EAEA,MAAM,aACJ,WACA,QACA,UACA,kBACA;AACA,WAAO,KAAK;AAAA,MACV,CAAC,SAAS;AAAA,MACV,CAAC,MAAM;AAAA,MACP;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,gBACJ,SACA,WACA,kBACA;AACA,UAAM,KAAK,IAAI,WAAW;AAC1B,OAAG,gBAAgB,SAAS,SAAS;AACrC,WAAO,KAAK,eAAe,IAAI,gBAAgB;AAAA,EACjD;AAAA,EAEA,MAAM,SAAS,YAKZ;AACD,UAAM;AAAA,MACJ;AAAA,MACA,WAAW,OAAO,CAAC;AAAA,MACnB,gBAAgB,CAAC;AAAA,MACjB;AAAA,IACF,IAAI;AACJ,UAAM,KAAK,IAAI,WAAW;AAC1B,OAAG,SAAS,QAAQ,MAAM,aAAa;AACvC,WAAO,KAAK,eAAe,IAAI,gBAAgB;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,sBACJ,QACA,UACA,OACA;AACA,YAAQ,SAAS,KAAK,eAAe;AACrC,UAAM,QAAQ,MAAM,KAAK,cAAc,YAAY,OAAO,QAAQ,QAAQ;AAC1E,WAAO,MAAM,IAAI,CAAC,MAAM,EAAE,QAAQ;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,SACJ,QACA,eACA,kBACA;AACA,UAAM,KAAK,IAAI,WAAW;AAC1B,OAAG,SAAS,QAAQ,aAAa;AACjC,WAAO,KAAK,eAAe,IAAI,gBAAgB;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,WACJ,IACA,kBAC4B;AAC5B,UAAM,UAAU,cAAc,aAAa,GAAG,UAAU;AACxD,WAAO,KAAK,cAAc,cAAc,2BAA2B;AAAA,MACjE,kBAAkB;AAAA,MAClB,QAAQ,KAAK,WAAW,gBAAgB;AAAA,IAC1C,CAAC;AAAA,EACH;AACF;;;AWxSA,sBAAkC;;;ACClC,IAAAC,kBAAiC;AACjC,IAAAC,gBAAwB;AAEjB,SAAS,2BAA2B,WAA8B;AACvE,MAAI,YAAQ,uBAAQ,SAAS;AAE7B,MAAI,MAAM,WAAW,MAAM,MAAM,WAAW;AAAI,UAAM;AACtD,UAAQ,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,IAAI;AAC/C,SAAO,IAAI,iCAAiB,KAAK;AACnC;;;ADDO,IAAM,iBAAN,MAAM,gBAAe;AAAA,EAI1B,YAAY,KAA4B,WAAmB;AACzD,SAAK,iBAAiB;AACtB,SAAK,YAAY;AACjB,SAAK,oBAAoB,kCAAkB,eAAe;AAAA,MACxD,WAAW,KAAK;AAAA,MAChB,YAAY,KAAK;AAAA,IACnB,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,yBACL,eACA,SACA,WACgB;AAChB,UAAM,MAAM,cAAc,IAAI,CAAC,cAAc,MAAM;AACjD,aAAO;AAAA,QACL,WAAW,2BAA2B,YAAY;AAAA,QAClD,QAAQ,QAAQ,CAAC;AAAA,MACnB;AAAA,IACF,CAAC;AACD,WAAO,IAAI,gBAAe,KAAK,SAAS;AAAA,EAC1C;AAAA,EAEA,kBAA0B;AACxB,WAAO,KAAK,kBAAkB,aAAa;AAAA,EAC7C;AAAA,EAEA,mBAAmB,MAAwB;AACzC,WAAO,KAAK,kBAAkB,yBAAyB,IAAI;AAAA,EAC7D;AACF;","names":["import_client","import_transactions","import_ed25519","genMnemonic","import_transactions","import_utils","import_utils","import_bcs","import_ed25519","import_utils"]}