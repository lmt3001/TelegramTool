"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Twisters = exports.defaultRender = void 0;
const spinners_1 = require("./spinners");
const utils_1 = require("./utils");
/**
 * The function used to render messages if a render function is not defined by the Message object.
 */
function defaultRender(message, frame) {
    const { active, text } = message;
    return active && frame ? `${frame} ${text}` : text;
}
exports.defaultRender = defaultRender;
class Twisters {
    /**
     * Create new Twisters instance
     * @param options
     * @param buffer __DEPRECATED__ Please define `buffer` in `options` instead of passing it as the second constructor parameter
     */
    constructor(options, buffer) {
        this.options = Object.assign({ buffer: (options === null || options === void 0 ? void 0 : options.buffer) || buffer || new utils_1.LineBuffer(), spinner: utils_1.terminalSupportsUnicode() ? spinners_1.dots : spinners_1.dashes, flushInactive: true, pinActive: false }, options);
        this.lineBuffer = this.options.buffer;
        this.spinnerLoop = utils_1.createSpinnerLoop(this.options.spinner);
        this.messages = new Map();
    }
    /**
     * Get buffered message by name.
     */
    pick(name) {
        return this.messages.get(name);
    }
    /**
     * Get buffered message count.
     */
    messageCount() {
        return this.messages.size;
    }
    /**
     * Iterate over buffered messages and invoke the callback for each one.
     */
    forEachMessage(callback) {
        this.messages.forEach(callback);
    }
    /**
     * Returns true if any of the buffered messages are active, otherwise false.
     */
    hasActiveMessage() {
        return Array.from(this.messages.values()).some(({ active, removed }) => active && !removed);
    }
    /**
     * Add/update a message
     *
     * @remarks Message content is not cached by default.
     * **This means that message text must be provided to subsequent `put` calls,
     * even if the text is unchanged.**
     * See {@Link https://github.com/adamjarret/twisters/blob/master/packages/examples-js/bin/custom-cache.js | custom-cache.js example} to update messages using only changed attributes.
     */
    put(name, messageOpt) {
        const { messageDefaults, buffer } = this.options;
        const message = Object.assign(Object.assign({ text: name, active: true, removed: false, render: defaultRender }, messageDefaults), messageOpt);
        if (buffer.isDisabled) {
            if (!message.removed) {
                buffer.write(message.render(message, null, name), false);
            }
        }
        else {
            this.messages.set(name, message);
            this.refresh();
        }
        return message;
    }
    /**
     * Log an inactive message
     * (convenience function equivalent to `put('text', { active: false })`)
     */
    log(text, messageOpt) {
        return this.put(text, Object.assign({ active: false }, messageOpt));
    }
    /**
     * Remove a buffered message by name
     * (convenience function equivalent to `put('name', { removed: true })`)
     * @returns The existing message that was removed or undefined if no message was found for the provided key
     */
    remove(name) {
        const message = this.pick(name);
        this.put(name, { removed: true });
        return message;
    }
    /**
     * Flush messages to stream.
     * @remarks This is called automatically if the `flushInactive` option is true.
     * Otherwise this must be called manually when all messages have finished.
     */
    flush() {
        const { buffer } = this.options;
        if (buffer.isDisabled) {
            return;
        }
        this.spinnerLoop.stop();
        this.updateBuffer();
        buffer.cleanup && buffer.cleanup();
        this.messages.clear();
    }
    refresh() {
        const { buffer, flushInactive } = this.options;
        if (flushInactive && !this.hasActiveMessage()) {
            this.flush();
        }
        else {
            buffer.init && buffer.init();
            this.spinnerLoop.start((frame) => this.updateBuffer(frame));
        }
    }
    updateBuffer(frame = '') {
        const { buffer, flushInactive, pinActive } = this.options;
        const pinned = new Map();
        let foundActive = false;
        let foundRemoved = false;
        buffer.updateBegin && buffer.updateBegin();
        // Write/pin/remove each message
        this.forEachMessage((message, name) => {
            if (message.removed) {
                if (!foundRemoved) {
                    buffer.teardown && buffer.teardown();
                    foundRemoved = true;
                }
                this.messages.delete(name);
                return;
            }
            if (message.active) {
                if (pinActive) {
                    pinned.set(name, message);
                    return;
                }
                foundActive = true;
            }
            const isBuffered = foundActive || !flushInactive;
            buffer.write(message.render(message, frame, name), isBuffered);
            if (!isBuffered) {
                this.messages.delete(name);
            }
        });
        // Write each pinned message (always active and buffered)
        pinned.forEach((message, name) => {
            buffer.write(message.render(message, frame, name), true);
        });
        buffer.updateEnd && buffer.updateEnd();
    }
}
exports.Twisters = Twisters;
exports.default = Twisters;
