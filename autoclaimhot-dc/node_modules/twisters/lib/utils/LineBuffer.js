"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineBuffer = void 0;
const readline_1 = __importDefault(require("readline"));
const string_width_1 = __importDefault(require("string-width"));
const constants_1 = require("./constants");
const wrapText_1 = __importDefault(require("./wrapText"));
class LineBuffer {
    constructor(options) {
        this.options = Object.assign({ EOL: '\n', disable: !!process.env.CI, discardStdin: true, handleSigint: true, stream: process.stderr, truncate: true, wordWrap: false }, options);
        const { disable, handleSigint, stream } = this.options;
        this.lineCount = 0;
        this.isDisabled = disable || !stream || !stream.isTTY;
        if (handleSigint) {
            process.on('SIGINT', () => {
                this.cleanup();
                // Emulate default node behavior (exit with code 128 + signal number)
                process.exit(128 + 2);
            });
        }
    }
    /**
     * 1. Hide the terminal cursor.
     * 2. Mute stdin (if discardStdin option is true).
     */
    init() {
        if (!this.isDisabled) {
            constants_1.sharedCursor.hide();
            if (this.options.discardStdin) {
                constants_1.sharedStdinMuter === null || constants_1.sharedStdinMuter === void 0 ? void 0 : constants_1.sharedStdinMuter.mute();
            }
        }
    }
    /**
     * Reset the line counter.
     */
    updateBegin() {
        if (this.isDisabled)
            return;
        this.lineCount = 0;
    }
    /**
     * 1. Clear from the cursor to the end of the screen.
     * 2. Move the cursor to top of buffered content.
     */
    updateEnd() {
        const { stream } = this.options;
        if (!stream || this.isDisabled)
            return;
        readline_1.default.clearScreenDown(stream);
        readline_1.default.moveCursor(stream, 0, -this.lineCount);
    }
    /**
     * Clear from the cursor to the end of the screen.
     */
    teardown() {
        const { stream } = this.options;
        if (!stream || this.isDisabled)
            return;
        readline_1.default.clearScreenDown(stream);
    }
    /**
     * 1. Restore terminal cursor visibility and position.
     * 2. Unmute stdin (if it was previously muted).
     * @remarks If the handleSigint option is false, this method should be called from any custom
     * sigint handler.
     */
    cleanup() {
        const { stream } = this.options;
        if (!stream || this.isDisabled)
            return;
        constants_1.sharedCursor.show();
        readline_1.default.moveCursor(stream, 0, this.lineCount);
        constants_1.sharedStdinMuter === null || constants_1.sharedStdinMuter === void 0 ? void 0 : constants_1.sharedStdinMuter.unmute();
    }
    /**
     * Write text to the stream.
     *
     * __Usage Notes:__
     * - The `updateStart` method should be called to start an update batch before writing buffered messages.
     * - The `updateEnd` method should be called to signify the end of an update batch after messages are written.
     * - Unbuffered messages should NOT be written AFTER buffered messages within an update batch.
     * - Unbuffered messages may be written outside of an update batch.
     */
    write(text, isBuffered = true) {
        const { stream, truncate, wordWrap, EOL } = this.options;
        if (!stream || text === null)
            return;
        const maxColumns = stream.columns;
        const wrapped = isBuffered ? wrapText_1.default(text, maxColumns, wordWrap) : text;
        const lines = wrapped.split(EOL);
        lines.forEach((line) => {
            if (!this.isDisabled && truncate && this.lineCount >= stream.rows - 1) {
                return;
            }
            stream.write(line);
            if (!this.isDisabled && string_width_1.default(line) < maxColumns) {
                readline_1.default.clearLine(stream, 1); // Clear from cursor to end of line
            }
            stream.write(EOL);
            if (isBuffered) {
                this.lineCount++;
            }
        });
    }
}
exports.LineBuffer = LineBuffer;
