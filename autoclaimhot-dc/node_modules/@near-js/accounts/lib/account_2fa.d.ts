import { FinalExecutionOutcome } from '@near-js/types';
import { SignAndSendTransactionOptions } from './account';
import { AccountMultisig } from './account_multisig';
import { Connection } from './connection';
type sendCodeFunction = () => Promise<any>;
type getCodeFunction = (method: any) => Promise<string>;
type verifyCodeFunction = (securityCode: any) => Promise<any>;
export declare class Account2FA extends AccountMultisig {
    /********************************
    Account2FA has options object where you can provide callbacks for:
    - sendCode: how to send the 2FA code in case you don't use NEAR Contract Helper
    - getCode: how to get code from user (use this to provide custom UI/UX for prompt of 2FA code)
    - onResult: the tx result after it's been confirmed by NEAR Contract Helper
    ********************************/
    sendCode: sendCodeFunction;
    getCode: getCodeFunction;
    verifyCode: verifyCodeFunction;
    onConfirmResult: (any: any) => any;
    helperUrl: string;
    constructor(connection: Connection, accountId: string, options: any);
    /**
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
     *
     * @param options Options for the transaction.
     * @param options.receiverId The NEAR account ID of the transaction receiver.
     * @param options.actions The list of actions to be included in the transaction.
     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
     */
    signAndSendTransaction({ receiverId, actions }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome>;
    /**
     * Deploy a multisig contract with 2FA and handle the deployment process.
     * @param contractBytes - The bytecode of the multisig contract.
     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deployment.
     */
    deployMultisig(contractBytes: Uint8Array): Promise<FinalExecutionOutcome>;
    /**
     * Disable 2FA with the option to clean up contract state.
     * @param options Options for disabling 2FA.
     * @param options.contractBytes The bytecode of the contract to deploy.
     * @param options.cleanupContractBytes The bytecode of the cleanup contract (optional).
     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
     */
    disableWithFAK({ contractBytes, cleanupContractBytes }: {
        contractBytes: Uint8Array;
        cleanupContractBytes?: Uint8Array;
    }): Promise<FinalExecutionOutcome>;
    /**
     * Retrieves cleanup actions for disabling 2FA.
     * @param cleanupContractBytes - The bytecode of the cleanup contract.
     * @returns {Promise<Action[]>} - A promise that resolves to an array of cleanup actions.
     */
    get2faDisableCleanupActions(cleanupContractBytes: Uint8Array): Promise<import("@near-js/transactions").Action[]>;
    /**
     * Retrieves key conversion actions for disabling 2FA.
     * @returns {Promise<Action[]>} - A promise that resolves to an array of key conversion actions.
     */
    get2faDisableKeyConversionActions(): Promise<import("@near-js/transactions").Action[]>;
    /**
     * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)
     * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}
     * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-manipulation/res/state_cleanup.wasm?raw=true}
     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
     */
    disable(contractBytes: Uint8Array, cleanupContractBytes: Uint8Array): Promise<FinalExecutionOutcome>;
    /**
     * Default implementation for sending the 2FA code.
     * @returns {Promise<string>} - A promise that resolves to the request ID.
     */
    sendCodeDefault(): Promise<any>;
    getCodeDefault(): Promise<string>;
    /**
     * Prompts the user to enter and verify the 2FA code.
     * @returns {Promise<any>} - A promise that resolves to the verification result.
     */
    promptAndVerify(): any;
    /**
     * Verify the 2FA code using the default method.
     * @param securityCode - The security code to verify.
     * @returns {Promise<any>} A promise that resolves to the verification result.
     */
    verifyCodeDefault(securityCode: string): Promise<any>;
    /**
     * Retrieves recovery methods for the account.
     * @returns {Promise<{ accountId: string, data: any }>} - A promise that resolves to recovery methods data.
     */
    getRecoveryMethods(): Promise<{
        accountId: string;
        data: any;
    }>;
    /**
     * Gets the 2FA method (kind and detail).
     * @returns {Promise<{ kind: string, detail: string }>} A promise that resolves to the 2FA method.
     */
    get2faMethod(): Promise<{
        kind: any;
        detail: any;
    }>;
    /**
    * Generates a signature for the latest finalized block.
    * @returns {Promise<{ blockNumber: string, blockNumberSignature: string }>} - A promise that resolves to the signature information.
    */
    signatureFor(): Promise<{
        blockNumber: string;
        blockNumberSignature: string;
    }>;
    /**
    * Sends a signed JSON request to a specified path.
    * @param path - The path for the request.
    * @param body - The request body.
    * @returns {Promise<any>} - A promise that resolves to the response from the helper.
    */
    postSignedJson(path: any, body: any): Promise<any>;
}
export {};
//# sourceMappingURL=account_2fa.d.ts.map