"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectedWalletAccount = exports.WalletConnection = void 0;
/**
 * This module exposes two classes:
 * * {@link WalletConnection} which redirects users to [NEAR Wallet](https://wallet.near.org/) for key management.
 * * {@link ConnectedWalletAccount} is an {@link "@near-js/accounts".account.Account | Account} implementation that uses {@link WalletConnection} to get keys
 *
 * @module walletAccount
 */
const accounts_1 = require("@near-js/accounts");
const crypto_1 = require("@near-js/crypto");
const utils_1 = require("@near-js/utils");
const transactions_1 = require("@near-js/transactions");
const bn_js_1 = __importDefault(require("bn.js"));
const borsh_1 = require("borsh");
const LOGIN_WALLET_URL_SUFFIX = '/login/';
const MULTISIG_HAS_METHOD = 'add_request_and_confirm';
const LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';
const PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)
/**
 * This class is not intended for use outside the browser. Without `window` (i.e. in server contexts), it will instantiate but will throw a clear error when used.
 *
 * @see [https://docs.near.org/tools/near-api-js/quick-reference#wallet](https://docs.near.org/tools/near-api-js/quick-reference#wallet)
 * @example
 * ```js
 * // create new WalletConnection instance
 * const wallet = new WalletConnection(near, 'my-app');
 *
 * // If not signed in redirect to the NEAR wallet to sign in
 * // keys will be stored in the BrowserLocalStorageKeyStore
 * if(!wallet.isSignedIn()) return wallet.requestSignIn()
 * ```
 */
class WalletConnection {
    constructor(near, appKeyPrefix) {
        if (typeof (appKeyPrefix) !== 'string') {
            throw new Error('Please define a clear appKeyPrefix for this WalletConnection instance as the second argument to the constructor');
        }
        if (typeof window === 'undefined') {
            return new Proxy(this, {
                get(target, property) {
                    if (property === 'isSignedIn') {
                        return () => false;
                    }
                    if (property === 'getAccountId') {
                        return () => '';
                    }
                    if (target[property] && typeof target[property] === 'function') {
                        return () => {
                            throw new Error('No window found in context, please ensure you are using WalletConnection on the browser');
                        };
                    }
                    return target[property];
                }
            });
        }
        this._near = near;
        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
        const authData = JSON.parse(window.localStorage.getItem(authDataKey));
        this._networkId = near.config.networkId;
        this._walletBaseUrl = near.config.walletUrl;
        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';
        this._keyStore = near.connection.signer.keyStore;
        this._authData = authData || { allKeys: [] };
        this._authDataKey = authDataKey;
        if (!this.isSignedIn()) {
            this._completeSignInPromise = this._completeSignInWithAccessKey();
        }
    }
    /**
     * Returns true, if this WalletConnection is authorized with the wallet.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.isSignedIn();
     * ```
     */
    isSignedIn() {
        return !!this._authData.accountId;
    }
    /**
     * Returns promise of completing signing in after redirecting from wallet
     * @example
     * ```js
     * // on login callback page
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.isSignedIn(); // false
     * await wallet.isSignedInAsync(); // true
     * ```
     */
    isSignedInAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._completeSignInPromise) {
                return this.isSignedIn();
            }
            yield this._completeSignInPromise;
            return this.isSignedIn();
        });
    }
    /**
     * Returns authorized Account ID.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.getAccountId();
     * ```
     */
    getAccountId() {
        return this._authData.accountId || '';
    }
    /**
     * Constructs string URL to the wallet authentication page.
     * @param options An optional options object
     * @param options.contractId The NEAR account where the contract is deployed
     * @param options.successUrl URL to redirect upon success. Default: current url
     * @param options.failureUrl URL to redirect upon failure. Default: current url
     *
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * // return string URL to the NEAR Wallet
     * const url = await wallet.requestSignInUrl({ contractId: 'account-with-deploy-contract.near' });
     * ```
     */
    requestSignInUrl({ contractId, methodNames, successUrl, failureUrl }) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentUrl = new URL(window.location.href);
            const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);
            newUrl.searchParams.set('success_url', successUrl || currentUrl.href);
            newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);
            if (contractId) {
                /* Throws exception if contract account does not exist */
                const contractAccount = yield this._near.account(contractId);
                yield contractAccount.state();
                newUrl.searchParams.set('contract_id', contractId);
                const accessKey = crypto_1.KeyPair.fromRandom('ed25519');
                newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());
                yield this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);
            }
            if (methodNames) {
                methodNames.forEach(methodName => {
                    newUrl.searchParams.append('methodNames', methodName);
                });
            }
            return newUrl.toString();
        });
    }
    /**
     * Redirects current page to the wallet authentication page.
     * @param options An optional options object
     * @param options.contractId The NEAR account where the contract is deployed
     * @param options.successUrl URL to redirect upon success. Default: current url
     * @param options.failureUrl URL to redirect upon failure. Default: current url
     *
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * // redirects to the NEAR Wallet
     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
     * ```
     */
    requestSignIn(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this.requestSignInUrl(options);
            window.location.assign(url);
        });
    }
    /**
     * Constructs string URL to the wallet to sign a transaction or batch of transactions.
     *
     * @param options A required options object
     * @param options.transactions List of transactions to sign
     * @param options.callbackUrl URL to redirect upon success. Default: current url
     * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param
     *
     */
    requestSignTransactionsUrl({ transactions, meta, callbackUrl }) {
        const currentUrl = new URL(window.location.href);
        const newUrl = new URL('sign', this._walletBaseUrl);
        newUrl.searchParams.set('transactions', transactions
            .map(transaction => (0, borsh_1.serialize)(transactions_1.SCHEMA.Transaction, transaction))
            .map(serialized => Buffer.from(serialized).toString('base64'))
            .join(','));
        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);
        if (meta)
            newUrl.searchParams.set('meta', meta);
        return newUrl.toString();
    }
    /**
     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the wallet.
     *
     * @param options A required options object
     * @param options.transactions List of transactions to sign
     * @param options.callbackUrl URL to redirect upon success. Default: current url
     * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param
     *
     */
    requestSignTransactions(options) {
        const url = this.requestSignTransactionsUrl(options);
        window.location.assign(url);
    }
    /**
     * @hidden
     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
     */
    _completeSignInWithAccessKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentUrl = new URL(window.location.href);
            const publicKey = currentUrl.searchParams.get('public_key') || '';
            const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');
            const accountId = currentUrl.searchParams.get('account_id') || '';
            // TODO: Handle errors during login
            if (accountId) {
                const authData = {
                    accountId,
                    allKeys
                };
                window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));
                if (publicKey) {
                    yield this._moveKeyFromTempToPermanent(accountId, publicKey);
                }
                this._authData = authData;
            }
            currentUrl.searchParams.delete('public_key');
            currentUrl.searchParams.delete('all_keys');
            currentUrl.searchParams.delete('account_id');
            currentUrl.searchParams.delete('meta');
            currentUrl.searchParams.delete('transactionHashes');
            window.history.replaceState({}, document.title, currentUrl.toString());
        });
    }
    /**
     * @hidden
     * @param accountId The NEAR account owning the given public key
     * @param publicKey The public key being set to the key store
     */
    _moveKeyFromTempToPermanent(accountId, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
            yield this._keyStore.setKey(this._networkId, accountId, keyPair);
            yield this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
        });
    }
    /**
     * Sign out from the current account
     * @example
     * walletConnection.signOut();
     */
    signOut() {
        this._authData = {};
        window.localStorage.removeItem(this._authDataKey);
    }
    /**
     * Returns the current connected wallet account
     */
    account() {
        if (!this._connectedAccount) {
            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);
        }
        return this._connectedAccount;
    }
}
exports.WalletConnection = WalletConnection;
/**
 * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.
 */
class ConnectedWalletAccount extends accounts_1.Account {
    constructor(walletConnection, connection, accountId) {
        super(connection, accountId);
        this.walletConnection = walletConnection;
    }
    // Overriding Account methods
    /**
     * Sign a transaction by redirecting to the NEAR Wallet
     * @see {@link WalletConnection#requestSignTransactions}
     * @param options An optional options object
     * @param options.receiverId The NEAR account ID of the transaction receiver.
     * @param options.actions An array of transaction actions to be performed.
     * @param options.walletMeta Additional metadata to be included in the wallet signing request.
     * @param options.walletCallbackUrl URL to redirect upon completion of the wallet signing process. Default: current URL.
     */
    signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {
        const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const localKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
            let accessKey = yield this.accessKeyForTransaction(receiverId, actions, localKey);
            if (!accessKey) {
                throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
            }
            if (localKey && localKey.toString() === accessKey.public_key) {
                try {
                    return yield _super.signAndSendTransaction.call(this, { receiverId, actions });
                }
                catch (e) {
                    if (e.type === 'NotEnoughAllowance') {
                        accessKey = yield this.accessKeyForTransaction(receiverId, actions);
                    }
                    else {
                        throw e;
                    }
                }
            }
            const block = yield this.connection.provider.block({ finality: 'final' });
            const blockHash = (0, utils_1.baseDecode)(block.header.hash);
            const publicKey = crypto_1.PublicKey.from(accessKey.public_key);
            // TODO: Cache & listen for nonce updates for given access key
            const nonce = accessKey.access_key.nonce.add(new bn_js_1.default(1));
            const transaction = (0, transactions_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);
            yield this.walletConnection.requestSignTransactions({
                transactions: [transaction],
                meta: walletMeta,
                callbackUrl: walletCallbackUrl
            });
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(new Error('Failed to redirect to sign transaction'));
                }, 1000);
            });
            // TODO: Aggregate multiple transaction request with "debounce".
            // TODO: Introduce TransactionQueue which also can be used to watch for status?
        });
    }
    /**
     * Check if given access key allows the function call or method attempted in transaction
     * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
     * @param receiverId The NEAR account attempting to have access
     * @param actions The action(s) needed to be checked for access
     */
    accessKeyMatchesTransaction(accessKey, receiverId, actions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { access_key: { permission } } = accessKey;
            if (permission === 'FullAccess') {
                return true;
            }
            if (permission.FunctionCall) {
                const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
                /********************************
                Accept multisig access keys and let wallets attempt to signAndSendTransaction
                If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153
                ********************************/
                if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
                    return true;
                }
                if (allowedReceiverId === receiverId) {
                    if (actions.length !== 1) {
                        return false;
                    }
                    const [{ functionCall }] = actions;
                    return functionCall &&
                        (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?
                        (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));
                    // TODO: Handle cases when allowance doesn't have enough to pay for gas
                }
            }
            // TODO: Support other permissions than FunctionCall
            return false;
        });
    }
    /**
     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
     * @param receiverId The NEAR account seeking the access key for a transaction
     * @param actions The action(s) sought to gain access to
     * @param localKey A local public key provided to check for access
     */
    accessKeyForTransaction(receiverId, actions, localKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessKeys = yield this.getAccessKeys();
            if (localKey) {
                const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());
                if (accessKey && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                    return accessKey;
                }
            }
            const walletKeys = this.walletConnection._authData.allKeys;
            for (const accessKey of accessKeys) {
                if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                    return accessKey;
                }
            }
            return null;
        });
    }
}
exports.ConnectedWalletAccount = ConnectedWalletAccount;
